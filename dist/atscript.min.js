(()=>{"use strict";var e,t,n={};n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),function(e){e[e.Eof=0]="Eof",e[e.Panic=1]="Panic",e[e.Lambda=2]="Lambda",e[e.Ampersand=3]="Ampersand",e[e.AtSign=4]="AtSign",e[e.Caret=5]="Caret",e[e.Comma=6]="Comma",e[e.Dollar=7]="Dollar",e[e.Dot=8]="Dot",e[e.Hash=9]="Hash",e[e.LeftBrace=10]="LeftBrace",e[e.LeftBracket=11]="LeftBracket",e[e.LeftParen=12]="LeftParen",e[e.Percent=13]="Percent",e[e.Pipe=14]="Pipe",e[e.RightBrace=15]="RightBrace",e[e.RightBracket=16]="RightBracket",e[e.RightParen=17]="RightParen",e[e.Semicolon=18]="Semicolon",e[e.Slash=19]="Slash",e[e.Star=20]="Star",e[e.Arrow=21]="Arrow",e[e.Bang=22]="Bang",e[e.BangEqual=23]="BangEqual",e[e.Colon=24]="Colon",e[e.Equal=25]="Equal",e[e.EqualEqual=26]="EqualEqual",e[e.Greater=27]="Greater",e[e.GreaterEqual=28]="GreaterEqual",e[e.Less=29]="Less",e[e.LessEqual=30]="LessEqual",e[e.Minus=31]="Minus",e[e.MinusEqual=32]="MinusEqual",e[e.MinusMinus=33]="MinusMinus",e[e.PercentEqual=34]="PercentEqual",e[e.Plus=35]="Plus",e[e.PlusEqual=36]="PlusEqual",e[e.PlusPlus=37]="PlusPlus",e[e.Question=38]="Question",e[e.QuestionDot=39]="QuestionDot",e[e.QuestionQuestion=40]="QuestionQuestion",e[e.SlashEqual=41]="SlashEqual",e[e.StarEqual=42]="StarEqual",e[e.DotDot=43]="DotDot",e[e.DotDotDot=44]="DotDotDot",e[e.LessEqualGreater=45]="LessEqualGreater",e[e.Identifier=46]="Identifier",e[e.Template=47]="Template",e[e.String=48]="String",e[e.Number=49]="Number",e[e.Regex=50]="Regex",e[e.And=51]="And",e[e.Break=52]="Break",e[e.Base=53]="Base",e[e.Class=54]="Class",e[e.Continue=55]="Continue",e[e.Delete=56]="Delete",e[e.Do=57]="Do",e[e.Else=58]="Else",e[e.Extends=59]="Extends",e[e.False=60]="False",e[e.For=61]="For",e[e.Foreach=62]="Foreach",e[e.Function=63]="Function",e[e.If=64]="If",e[e.In=65]="In",e[e.Instanceof=66]="Instanceof",e[e.Is=67]="Is",e[e.New=68]="New",e[e.None=69]="None",e[e.Null=70]="Null",e[e.Or=71]="Or",e[e.Print=72]="Print",e[e.Return=73]="Return",e[e.True=74]="True",e[e.Typeof=75]="Typeof",e[e.Var=76]="Var",e[e.Void=77]="Void",e[e.While=78]="While",e[e.With=79]="With"}(e||(e={}));class s{constructor(t,n,s,i,r){this.name=e[t],this.type=t,this.lexeme=n,this.literal=s,this.line=i,this.col=r}toString(){return`[(${this.line}):"${this.lexeme}"]`}}function i(e){return e>="0"&&e<="9"}function r(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"}function a(e){return e.charAt(0).toUpperCase()+e.substr(1).toLowerCase()}class o{scan(t){for(this.source=t,this.tokens=[],this.errors=[],this.current=0,this.start=0,this.line=1,this.col=1;!this.eof();){this.start=this.current;try{this.getToken()}catch(e){if(this.errors.push(e.message),this.errors.length>100)return this.errors.push("Error limit exceeded"),this.tokens}}return this.tokens.push(new s(e.Eof,"",null,this.line,0)),this.tokens}eof(){return this.current>=this.source.length}advance(){return"\n"===this.peek()&&(this.line++,this.col=0),this.current++,this.col++,this.source.charAt(this.current-1)}addToken(e,t){const n=this.source.substring(this.start,this.current);this.tokens.push(new s(e,n,t,this.line,this.col))}match(e){return!this.eof()&&(this.source.charAt(this.current)===e&&(this.current++,!0))}peek(){return this.eof()?"\0":this.source.charAt(this.current)}peekNext(){return this.current+1>=this.source.length?"\0":this.source.charAt(this.current+1)}comment(){for(;"\n"!==this.peek()&&!this.eof();)this.advance()}multilineComment(){for(;!this.eof()&&("*"!==this.peek()||"/"!==this.peekNext());)this.advance();this.eof()?this.error('Unterminated comment, expecting closing "*/"'):(this.advance(),this.advance())}string(t){for(;this.peek()!==t&&!this.eof();)this.advance();if(this.eof())return void this.error(`Unterminated string, expecting closing ${t}`);this.advance();const n=this.source.substring(this.start+1,this.current-1);this.addToken("`"!==t?e.String:e.Template,n)}number(){for(;i(this.peek());)this.advance();for("."===this.peek()&&i(this.peekNext())&&this.advance();i(this.peek());)this.advance();for("e"===this.peek().toLowerCase()&&(this.advance(),"-"!==this.peek()&&"+"!==this.peek()||this.advance());i(this.peek());)this.advance();const t=this.source.substring(this.start,this.current);this.addToken(e.Number,Number(t))}identifier(){for(;r(t=this.peek())||i(t);)this.advance();var t;const n=this.source.substring(this.start,this.current),s=a(n);e[s]>=e.And?this.addToken(e[s],n):this.addToken(e.Identifier,n)}getToken(){const t=this.advance();switch(t){case"(":this.addToken(e.LeftParen,null);break;case")":this.addToken(e.RightParen,null);break;case"[":this.addToken(e.LeftBracket,null);break;case"]":this.addToken(e.RightBracket,null);break;case"{":this.addToken(e.LeftBrace,null);break;case"}":this.addToken(e.RightBrace,null);break;case",":this.addToken(e.Comma,null);break;case";":this.addToken(e.Semicolon,null);break;case"^":this.addToken(e.Caret,null);break;case"$":this.addToken(e.Dollar,null);break;case"#":this.addToken(e.Hash,null);break;case"@":this.addToken(e.Function,"@");break;case":":this.addToken(this.match("=")?e.Arrow:e.Colon,null);break;case"*":this.addToken(this.match("=")?e.StarEqual:e.Star,null);break;case"%":this.addToken(this.match("=")?e.PercentEqual:e.Percent,null);break;case"|":this.addToken(this.match("|")?e.Or:e.Pipe,null);break;case"&":this.addToken(this.match("&")?e.And:e.Ampersand,null);break;case">":this.addToken(this.match("=")?e.GreaterEqual:e.Greater,null);break;case"!":this.addToken(this.match("=")?e.BangEqual:e.Bang,null);break;case"?":this.addToken(this.match("?")?e.QuestionQuestion:this.match(".")?e.QuestionDot:e.Question,null);break;case"=":this.addToken(this.match("=")?e.EqualEqual:this.match(">")?e.Arrow:e.Equal,null);break;case"+":this.addToken(this.match("+")?e.PlusPlus:this.match("=")?e.PlusEqual:e.Plus,null);break;case"-":this.addToken(this.match("-")?e.MinusMinus:this.match(">")?e.Return:this.match("=")?e.MinusEqual:e.Minus,null);break;case"<":this.addToken(this.match("=")?this.match(">")?e.LessEqualGreater:e.LessEqual:e.Less,null);break;case".":this.match(".")?this.match(".")?this.addToken(e.DotDotDot,null):this.addToken(e.DotDot,null):this.addToken(e.Dot,null);break;case"/":this.match("/")?this.comment():this.match("*")?this.multilineComment():this.addToken(this.match("=")?e.SlashEqual:e.Slash,null);break;case"'":case'"':case"`":this.string(t);break;case"\n":case" ":case"\r":case"\t":break;default:i(t)?this.number():r(t)?this.identifier():this.error(`Unexpected character '${t}'`)}}error(e){throw new Error(`Scan Error (${this.line}:${this.col}) => ${e}`)}}class l{constructor(){}}class u extends l{constructor(e,t,n){super(),this.name=e,this.value=t,this.line=n}accept(e){return e.visitAssignExpr(this)}toString(){return"Expr.Assign"}}class c extends l{constructor(e,t){super(),this.paren=e,this.line=t}accept(e){return e.visitBaseExpr(this)}toString(){return"Expr.Base"}}class h extends l{constructor(e,t,n,s){super(),this.left=e,this.operator=t,this.right=n,this.line=s}accept(e){return e.visitBinaryExpr(this)}toString(){return"Expr.Binary"}}class p extends l{constructor(e,t,n,s,i){super(),this.callee=e,this.paren=t,this.args=n,this.thiz=s,this.line=i}accept(e){return e.visitCallExpr(this)}toString(){return"Expr.Call"}}class m extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitCharExpr(this)}toString(){return"Expr.Char"}}class d extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitDeleteExpr(this)}toString(){return"Expr.Delete"}}class v extends l{constructor(e,t){super(),this.properties=e,this.line=t}accept(e){return e.visitDictionaryExpr(this)}toString(){return"Expr.Dictionary"}}class f extends l{constructor(e,t,n,s){super(),this.entity=e,this.key=t,this.type=n,this.line=s}accept(e){return e.visitGetExpr(this)}toString(){return"Expr.Get"}}class w extends l{constructor(e,t){super(),this.expression=e,this.line=t}accept(e){return e.visitGroupingExpr(this)}toString(){return"Expr.Grouping"}}class x extends l{constructor(e,t,n){super(),this.key=e,this.entity=t,this.line=n}accept(e){return e.visitInExpr(this)}toString(){return"Expr.In"}}class g extends l{constructor(e,t,n){super(),this.left=e,this.right=t,this.line=n}accept(e){return e.visitInstanceOfExpr(this)}toString(){return"Expr.InstanceOf"}}class E extends l{constructor(e,t,n){super(),this.left=e,this.right=t,this.line=n}accept(e){return e.visitIsExpr(this)}toString(){return"Expr.Is"}}class y extends l{constructor(e,t){super(),this.name=e,this.line=t}accept(e){return e.visitKeyExpr(this)}toString(){return"Expr.Key"}}class S extends l{constructor(e,t){super(),this.lambda=e,this.line=t}accept(e){return e.visitLambdaExpr(this)}toString(){return"Expr.Lambda"}}class k extends l{constructor(e,t,n,s){super(),this.left=e,this.operator=t,this.right=n,this.line=s}accept(e){return e.visitLogicalExpr(this)}toString(){return"Expr.Logical"}}class b extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitListExpr(this)}toString(){return"Expr.List"}}class L extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitLiteralExpr(this)}toString(){return"Expr.Literal"}}class P extends l{constructor(e,t){super(),this.clazz=e,this.line=t}accept(e){return e.visitNewExpr(this)}toString(){return"Expr.New"}}class B extends l{constructor(e,t,n){super(),this.left=e,this.right=t,this.line=n}accept(e){return e.visitNullCoalescingExpr(this)}toString(){return"Expr.NullCoalescing"}}class C extends l{constructor(e,t,n){super(),this.name=e,this.increment=t,this.line=n}accept(e){return e.visitPostfixExpr(this)}toString(){return"Expr.Postfix"}}class N extends l{constructor(e,t,n,s){super(),this.start=e,this.end=t,this.step=n,this.line=s}accept(e){return e.visitRangeExpr(this)}toString(){return"Expr.Range"}}class D extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitRegExExpr(this)}toString(){return"Expr.RegEx"}}class $ extends l{constructor(e,t,n,s){super(),this.entity=e,this.key=t,this.value=n,this.line=s}accept(e){return e.visitSetExpr(this)}toString(){return"Expr.Set"}}class R extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitSpreadExpr(this)}toString(){return"Expr.Spread"}}class q extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitTemplateExpr(this)}toString(){return"Expr.Template"}}class T extends l{constructor(e,t,n,s){super(),this.condition=e,this.thenExpr=t,this.elseExpr=n,this.line=s}accept(e){return e.visitTernaryExpr(this)}toString(){return"Expr.Ternary"}}class I extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitTypeofExpr(this)}toString(){return"Expr.Typeof"}}class M extends l{constructor(e,t,n){super(),this.operator=e,this.right=t,this.line=n}accept(e){return e.visitUnaryExpr(this)}toString(){return"Expr.Unary"}}class z extends l{constructor(e,t){super(),this.name=e,this.line=t}accept(e){return e.visitVariableExpr(this)}toString(){return"Expr.Variable"}}class A extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitVoidExpr(this)}toString(){return"Expr.Void"}}class F extends l{constructor(e,t){super(),this.value=e,this.line=t}accept(e){return e.visitZtringExpr(this)}toString(){return"Expr.Ztring"}}class O{constructor(){}}class G extends O{constructor(e,t){super(),this.statements=e,this.line=t}accept(e){return e.visitBlockStmt(this)}toString(){return"Stmt.Block"}}class j extends O{constructor(e,t){super(),this.keyword=e,this.line=t}accept(e){return e.visitBreakStmt(this)}toString(){return"Stmt.Break"}}class U extends O{constructor(e,t,n,s){super(),this.name=e,this.parent=t,this.methods=n,this.line=s}accept(e){return e.visitClassStmt(this)}toString(){return"Stmt.Class"}}class V extends O{constructor(e,t){super(),this.keyword=e,this.line=t}accept(e){return e.visitContinueStmt(this)}toString(){return"Stmt.Continue"}}class W extends O{constructor(e,t,n){super(),this.loop=e,this.condition=t,this.line=n}accept(e){return e.visitDoWhileStmt(this)}toString(){return"Stmt.DoWhile"}}class Q extends O{constructor(e,t){super(),this.expression=e,this.line=t}accept(e){return e.visitExpressionStmt(this)}toString(){return"Stmt.Expression"}}class K extends O{constructor(e,t,n,s,i){super(),this.initializer=e,this.condition=t,this.increment=n,this.loop=s,this.line=i}accept(e){return e.visitForStmt(this)}toString(){return"Stmt.For"}}class H extends O{constructor(e,t,n,s,i,r){super(),this.name=e,this.key=t,this.iterable=n,this.loop=s,this.none=i,this.line=r}accept(e){return e.visitForeachStmt(this)}toString(){return"Stmt.Foreach"}}class Z extends O{constructor(e,t,n,s){super(),this.name=e,this.params=t,this.body=n,this.line=s}accept(e){return e.visitFuncStmt(this)}toString(){return"Stmt.Func"}}class J extends O{constructor(e,t,n,s){super(),this.condition=e,this.thenStmt=t,this.elseStmt=n,this.line=s}accept(e){return e.visitIfStmt(this)}toString(){return"Stmt.If"}}class X extends O{constructor(e,t){super(),this.expression=e,this.line=t}accept(e){return e.visitPrintStmt(this)}toString(){return"Stmt.Print"}}class Y extends O{constructor(e,t,n){super(),this.keyword=e,this.value=t,this.line=n}accept(e){return e.visitReturnStmt(this)}toString(){return"Stmt.Return"}}class _ extends O{constructor(e,t,n,s){super(),this.name=e,this.type=t,this.initializer=n,this.line=s}accept(e){return e.visitVarStmt(this)}toString(){return"Stmt.Var"}}class ee extends O{constructor(e,t,n){super(),this.condition=e,this.loop=t,this.line=n}accept(e){return e.visitWhileStmt(this)}toString(){return"Stmt.While"}}!function(e){e[e.Null=0]="Null",e[e.Any=1]="Any",e[e.Boolean=2]="Boolean",e[e.Number=3]="Number",e[e.String=4]="String",e[e.List=5]="List",e[e.Dictionary=6]="Dictionary",e[e.Object=7]="Object",e[e.Class=8]="Class",e[e.Function=9]="Function",e[e.Lambda=10]="Lambda",e[e.Range=11]="Range",e[e.RegExp=12]="RegExp",e[e.Error=13]="Error",e[e.Iterator=14]="Iterator",e[e.Void=100]="Void",e[e.Return=101]="Return",e[e.Break=102]="Break",e[e.Continue=103]="Continue"}(t||(t={}));class te{constructor(e,n=t.Any){this.type=t.Any,this.value=e,this.type=n}isString(){return this.type===t.String}isNull(){return this.type===t.Null}isBoolean(){return this.type===t.Boolean}isNumber(){return this.type===t.Number}isRange(){return this.type===t.Range}isFunction(){return this.type===t.Function}isClass(){return this.type===t.Class}isLambda(){return this.type===t.Function&&"@"===this.name}isList(){return this.type===t.List}isDictionary(){return this.type===t.Dictionary}isObject(){return this.type===t.Object}isTruthy(){if(this.isNull())return!1;if(this.isBoolean())return Boolean(this.value);if(this.isNumber()&&0===this.value)return!1;if(this.isString()&&0===this.value.toString().length)return!1;if(this.isList()&&0===this.value.length)return!1;if(this.isDictionary()&&0===this.value.size)return!1;if(null===this.value)throw new Error("Unknown error value Any is null");if(void 0===this.value)throw new Error("Unknown error value Any is undefined");return!0}isEqual(e){return this.value===e.value}isKeyValue(){return this.type===t.Class||this.type===t.Dictionary||this.type===t.Object}get(e){throw conzole.error(`key ${e} does not exist in ${this}`),new Error("Error in Any getter")}set(e,t){throw conzole.error(`key ${e} does not exist in ${this}`),new Error("Error in Any setter")}delete(e){throw conzole.error(`${this} does not support operator`),new Error("Error in Any delete")}toString(){return this.value.toString()}}class ne extends te{constructor(e){super(e,t.Boolean)}}class se extends te{constructor(){super(null),this.type=t.Null}toString(){return"null"}}class ie extends te{constructor(e){super(e,t.Number)}toString(){return this.value.toString()}}class re extends te{constructor(e,n,s){super(e,t.Error),this.line=n,this.col=s}toString(){return this.value.toString()}}class ae{constructor(){this.errorLevel=1}parse(e){this.current=0,this.tokens=e,this.errors=[];const t=[];for(;!this.eof();)try{t.push(this.declaration())}catch(e){if(e instanceof re)this.errors.push(`Parse Error (${e.line}:${e.col}) => ${e.value}`);else if(this.errors.push(e),this.errors.length>100)return this.errors.push("Parse Error limit exceeded"),t;this.synchronize()}return t}match(...e){for(const t of e)if(this.check(t))return this.advance(),!0;return!1}advance(){return this.eof()||this.current++,this.previous()}peek(){return this.tokens[this.current]}previous(){return this.tokens[this.current-1]}peekNext(){return this.eof()?this.peek():this.tokens[this.current+1]}check(e){return this.peek().type===e}eof(){return this.check(e.Eof)}consume(e,t){return this.check(e)?this.advance():this.error(this.previous(),t+`, unexpected token "${this.peek().lexeme}"`)}extraSemicolon(){const t=this.match(e.Semicolon);if(this.check(e.Semicolon))for(;this.check(e.Semicolon);)this.consume(e.Semicolon,"");return t}error(e,t){throw new re(t,e.line,e.col)}warning(e){if(1===this.errorLevel){const t=this.previous();conzole.warn(`[line (${t.line}) parse warning at "${t.lexeme}"] => ${e}`)}}synchronize(){do{switch(this.peek().type){case e.Class:case e.Function:case e.Var:case e.For:case e.If:case e.While:case e.Do:case e.Print:case e.Return:return void this.advance()}if(this.check(e.Semicolon)||this.check(e.RightBrace))return void this.advance();this.advance()}while(!this.eof())}declaration(){return this.match(e.Class)?this.classDeclaration():this.match(e.Function)?this.funcDeclaration("function"):this.match(e.Var)?this.varDeclaration():this.statement()}classDeclaration(){const t=this.consume(e.Identifier,"Expected a class name");let n=null;this.match(e.Extends)&&(n=this.consume(e.Identifier,"Expected a parent name")),this.consume(e.LeftBrace,'Expected open brace "{" after class name');const s=[];for(;!this.check(e.RightBrace)&&!this.eof();)this.check(e.Function)&&this.consume(e.Function,""),s.push(this.funcDeclaration("method"));return this.consume(e.RightBrace,`Expected "}" after class "${t.literal}" methods`),this.extraSemicolon()&&this.warning(`Unnecessary semicolon after class ${t.lexeme} declaration`),new U(t,n,s,t.line)}funcDeclaration(t){const n=this.consume(e.Identifier,`Expected a ${t} name`);return this.funcParamsBody(n,t)}funcParams(t){const n=[];if(!this.check(e.RightParen))do{n.length>=255&&this.error(this.peek(),"Parameter count exceeds 255"),n.push(this.consume(e.Identifier,"Expected a parameter name"))}while(this.match(e.Comma));return this.consume(e.RightParen,`Expected close parenthesis ")" after ${t} parameters`),n}funcParamsBody(t,n){this.consume(e.LeftParen,`Expected open parenthesis "(" after ${n}`);const s=this.funcParams(n);if(this.match(e.LeftBrace)){const n=this.block();return t.type!==e.Lambda&&this.extraSemicolon()&&this.warning(`Unnecessary semicolon after function ${t.lexeme} declaration`),new Z(t,s,n,t.line)}if(this.match(e.Arrow)){const n=[];let i;const r=this.previous();return this.check(e.Semicolon)||(i=this.expression()),this.match(e.Semicolon),n.push(new Y(r,i,r.line)),new Z(t,s,n,t.line)}this.consume(e.LeftBrace,`Expect "{" before ${n} body`)}varDeclaration(){const t=this.consume(e.Identifier,'Expected a variable name after "var" keyword');let n=null;return this.match(e.Equal)&&(n=this.expression()),this.consume(e.Semicolon,'Expected semicolon ";" after a variable declaration'),new _(t,null,n,t.line)}statement(){return this.match(e.If)?this.ifStatement():this.match(e.Print)?this.printStatement():this.match(e.Do)?this.doWhileStatement():this.match(e.While)?this.whileStatement():this.match(e.For)?this.forStatement():this.match(e.Foreach)?this.foreachStatement():this.match(e.LeftBrace)?new G(this.block(),this.previous().line):this.match(e.Return)?this.returnStatement():this.match(e.Break)?this.breakStatement():this.match(e.Continue)?this.continueStatement():this.expressionStatement()}ifStatement(){const t=this.previous();this.consume(e.LeftParen,'Expected open parenthesis "(" after an "if" keyword');const n=this.expression();this.consume(e.RightParen,'Expected close parenthesis ")" after "if" statement condition');const s=this.statement();let i=null;return this.match(e.Else)&&(i=this.statement()),new J(n,s,i,t.line)}whileStatement(){const t=this.previous();this.consume(e.LeftParen,'Expected open parenthesis "(" after a "while" statement');const n=this.expression();this.consume(e.RightParen,'Expected close parenthesis ")" after "while" condition');const s=this.statement();return new ee(n,s,t.line)}forStatement(){const t=this.previous();let n,s,i;this.consume(e.LeftParen,'Expected open parenthesis "(" after a "for" statement'),n=this.match(e.Semicolon)?null:this.match(e.Var)?this.varDeclaration():this.expressionStatement(),this.check(e.Semicolon)||(s=this.expression()),this.consume(e.Semicolon,'Expected semicolon ";" after a "for" statement loop condition'),this.check(e.RightParen)||(i=this.expression()),this.consume(e.RightParen,'Expected semicolon ";" after a "for" stement increment expression');let r=this.statement();return new K(n,s,i,r,t.line)}foreachStatement(){const t=this.previous();this.consume(e.LeftParen,'Expected open parenthesis "(" after a "foreach" statement');const n=this.consume(e.Identifier,'Expected an identifier inside "foreach" statement');let s=null;this.match(e.With)&&(s=this.consume(e.Identifier,'Expected a "key" identifier after "with" keyword in foreach statement')),this.consume(e.In,'Expected "in" keyword inside foreach statement');const i=this.expression();this.consume(e.RightParen,'Expected close parenthesis ")" after a "foreach" initialization');const r=this.statement();let a=null;return this.match(e.None)&&(a=this.statement()),new H(n,s,i,r,a,t.line)}doWhileStatement(){const t=this.previous(),n=this.statement();this.consume(e.While,'Expected a "while" condition after "do" statement'),this.consume(e.LeftParen,'Expected open parenthesis "(" after a "while" keyword');const s=this.expression();return this.consume(e.RightParen,'Expected close parenthesis ")" after "while" condition'),this.consume(e.Semicolon,'Expected semicolon ";" after a do while condition'),new W(n,s,t.line)}printStatement(){const t=this.previous(),n=this.expression();return this.consume(e.Semicolon,'Expected semicolon ";" after expression'),new X(n,t.line)}returnStatement(){const t=this.previous();let n=null;return this.check(e.Semicolon)||(n=this.expression()),this.consume(e.Semicolon,'Exected semicolon ";" after return statement'),new Y(t,n,t.line)}breakStatement(){const t=this.previous();return this.consume(e.Semicolon,'Exected semicolon ";" after break statement'),new j(t,t.line)}continueStatement(){const t=this.previous();return this.consume(e.Semicolon,'Exected semicolon ";" after continue statement'),new V(t,t.line)}block(){const t=[];for(;!this.check(e.RightBrace)&&!this.eof();)t.push(this.declaration());return this.consume(e.RightBrace,'Expected close brace "}" after block statement'),t}expressionStatement(){const t=this.expression();if(this.consume(e.Semicolon,`Expected semicolon ";" after ${t} expression`),this.match(e.Semicolon)){const t=this.previous();for(this.warning(`[line (${t.line}) parse warning at "${t.lexeme}"] => unnecessary semicolon or empty statement`);this.match(e.Semicolon););}return new Q(t,t.line)}expression(){return this.assignment()}assignment(){const t=this.ternary();if(this.match(e.Equal,e.PlusEqual,e.MinusEqual,e.StarEqual,e.SlashEqual)){const n=this.previous();let s=this.assignment();if(t instanceof z){const i=t.name;return n.type!==e.Equal&&(s=new h(new z(i,i.line),n,s,n.line)),new u(i,s,i.line)}if(t instanceof f)return n.type!==e.Equal&&(s=new h(new f(t.entity,t.key,t.type,t.line),n,s,n.line)),new $(t.entity,t.key,s,t.line);this.error(n,"Invalid l-value, is not an assigning target.")}return t}ternary(){const t=this.nullCoalescing();if(this.match(e.Question)){const n=this.ternary();this.consume(e.Colon,'Expected ":" after ternary ? expression');const s=this.ternary();return new T(t,n,s,t.line)}return t}nullCoalescing(){const t=this.logicalOr();if(this.match(e.QuestionQuestion)){const e=this.nullCoalescing();return new B(t,e,t.line)}return t}logicalOr(){let t=this.logicalAnd();for(;this.match(e.Or);){const e=this.previous(),n=this.logicalAnd();t=new k(t,e,n,e.line)}return t}logicalAnd(){let t=this.equality();for(;this.match(e.And);){const e=this.previous(),n=this.equality();t=new k(t,e,n,e.line)}return t}equality(){let t=this.instanceof();for(;this.match(e.BangEqual,e.EqualEqual,e.LessEqualGreater);){const e=this.previous(),n=this.instanceof();t=new h(t,e,n,e.line)}return t}instanceof(){let t=this.in();for(;this.match(e.Is,e.Instanceof);){const n=this.previous();if(this.match(e.Identifier,e.Class,e.Function,e.Null)){const s=this.previous();t=n.type===e.Instanceof?new g(t,s,n.line):new E(t,s,n.line)}else this.error(this.previous(),'Expected a Type or ClassName identifier after "is" operator')}return t}in(){let t=this.comparison();for(;this.match(e.In);){const e=this.previous(),n=this.expression();t=new x(t,n,e.line)}return t}comparison(){let t=this.addition();for(;this.match(e.Greater,e.GreaterEqual,e.Less,e.LessEqual);){const e=this.previous(),n=this.addition();t=new h(t,e,n,e.line)}return t}addition(){let t=this.modulus();for(;this.match(e.Minus,e.Plus);){const e=this.previous(),n=this.modulus();t=new h(t,e,n,e.line)}return t}modulus(){let t=this.multiplication();for(;this.match(e.Percent);){const e=this.previous(),n=this.multiplication();t=new h(t,e,n,e.line)}return t}multiplication(){let t=this.typeof();for(;this.match(e.Slash,e.Star);){const e=this.previous(),n=this.typeof();t=new h(t,e,n,e.line)}return t}typeof(){if(this.match(e.Typeof)){const e=this.previous(),t=this.typeof();return new I(t,e.line)}return this.delete()}delete(){if(this.match(e.Delete)){const e=this.previous(),t=this.delete();return new d(t,e.line)}return this.range()}range(){let t=this.unary();if(this.match(e.DotDot)){const e=this.unary();t=new N(t,e,null,t.line)}return t}unary(){if(this.match(e.Minus,e.Bang,e.Dollar,e.PlusPlus,e.MinusMinus)){const e=this.previous(),t=this.unary();return new M(e,t,e.line)}return this.newKeyword()}newKeyword(){if(this.match(e.New)){const e=this.previous(),t=this.call();return new P(t,e.line)}return this.call()}call(){let t=this.primary(),n=!0;do{if(n=!1,this.match(e.LeftParen)){n=!0;do{const n=[];if(!this.check(e.RightParen))do{n.push(this.expression())}while(this.match(e.Comma));const s=this.consume(e.RightParen,'Expected ")" after arguments');t=new p(t,s,n,null,s.line)}while(this.match(e.LeftParen))}this.match(e.Dot,e.QuestionDot)&&(n=!0,t=this.dotGet(t,this.previous())),this.match(e.LeftBracket)&&(n=!0,t=this.bracketGet(t,this.previous()))}while(n);return t}dotGet(t,n){const s=this.consume(e.Identifier,"Expect property name after '.'"),i=new y(s,s.line);return new f(t,i,n.type,s.line)}bracketGet(t,n){let s=null,i=null,r=new L(new ie(1),n.line),a=!1;if(this.check(e.Colon)||(s=this.expression()),this.match(e.Colon)&&!this.check(e.Colon)&&(a=!0,i=this.expression()),this.match(e.Colon)&&!this.check(e.RightBracket)&&(a=!0,r=this.expression()),this.consume(e.RightBracket,'Expected "]" after an index'),a){const e=new N(s,i,r,n.line);return new f(t,e,n.type,n.line)}return new f(t,s,n.type,n.line)}primary(){if(this.match(e.False))return new L(new ne(!1),this.previous().line);if(this.match(e.True))return new L(new ne(!0),this.previous().line);if(this.match(e.Null))return new L(new se,this.previous().line);if(this.match(e.Number))return new L(new ie(this.previous().literal),this.previous().line);if(this.match(e.String))return new F(this.previous().literal,this.previous().line);if(this.match(e.Template))return new q(this.previous().literal,this.previous().line);if(this.match(e.Regex))return new D(this.previous().literal,this.previous().line);if(this.match(e.Base)){const e=this.previous();return e.lexeme="this",new c(e,e.line)}if(this.match(e.Identifier)){const t=this.previous();return this.match(e.PlusPlus)?new C(t,1,t.line):this.match(e.MinusMinus)?new C(t,-1,t.line):new z(t,t.line)}if(this.match(e.LeftParen)){const t=this.expression();return this.consume(e.RightParen,'Expected ")" after expression'),new w(t,t.line)}if(this.match(e.LeftBrace))return this.dictionary();if(this.match(e.Function)){const t=new s(e.Lambda,"@","@",this.previous().line,this.previous().col),n=this.funcParamsBody(t,"lambda");return new S(n,t.line)}if(this.match(e.LeftBracket))return this.list();if(this.match(e.Void)){const e=this.expression();return new A(e,this.previous().line)}if(this.match(e.DotDotDot)){const e=this.range();return new R(e,this.previous().line)}if(this.match(e.Hash))return new m(this.call(),this.previous().line);throw this.error(this.peek(),`Expected expression, unexpected token "${this.peek().lexeme}"`)}dictionary(){const t=this.previous();if(this.match(e.RightBrace))return new v([],this.previous().line);const n=[];do{if(this.match(e.String,e.Identifier,e.Number)){const t=this.previous();if(this.match(e.Colon)){const e=this.expression();n.push(new $(null,new y(t,t.line),e,t.line))}else{const e=new z(t,t.line);n.push(new $(null,new y(t,t.line),e,t.line))}}else if(this.match(e.DotDotDot)){const e=this.expression();n.push(new R(e,e.line))}else this.error(this.peek(),`String, Number or Identifier expected as a Key of Dictionary {, unexpected token ${this.peek().lexeme}`)}while(this.match(e.Comma));return this.consume(e.RightBrace,'Expected "}" after object literal'),new v(n,t.line)}list(){const t=[],n=this.previous();if(this.match(e.RightBracket))return new b([],this.previous().line);if(this.peekNext().type===e.Colon){let s=new L(new ie(1),n.line);const i=this.expression();this.consume(e.Colon,'Expected ":" color after start of range expression');const r=this.expression();this.consume(e.Colon,'Expected ":" color after end of range expression'),this.check(e.RightBracket)||(s=this.expression()),t.push(new N(i,r,s,i.line))}else do{t.push(this.expression())}while(this.match(e.Comma));return this.consume(e.RightBracket,'Expected "]" after array declaration'),new b(t,n.line)}}class oe{constructor(e=null){this.values=new Map,this.parent=e}error(e){throw new Error(`Runtime Error => ${e}`)}clone(){const e=new oe(this.parent);return e.values=new Map(this.values),e}set(e,t){this.values.set(e,t)}define(e,t){this.values.has(e)?this.error(`Identifier "${e}" has already been defined`):this.set(e,t)}assign(e,t){if(this.values.has(e))this.set(e,t);else{if(null!==this.parent)return this.parent.assign(e,t);this.error(`Identifier "${e}" has not been defined`)}}get(e,t=null){return this.values.has(e)?this.values.get(e):null!==this.parent?this.parent.get(e):(t?this.error(` at (${t.line}:${t.col}) => "${t.lexeme}" is not defined`):this.error(`"${e}" is not defined`),new se)}}class le extends te{constructor(e,n,s){super(s,t.Function),this.arity=n,this.name=e}call(e,t,n){return this.value(e,t,n)}toString(){return`<${this.name}  function>`}}class ue extends le{constructor(e,t){super(e.name.lexeme,e.params.length,null),this.declaration=e,this.closure=t}call(e,n,s){const i=new oe(this.closure);for(let e=0;e<this.declaration.params.length;e++)i.define(this.declaration.params[e].lexeme,n[e]);i.set("this",e);let r=null;try{r=s.scope,s.executeBlock(this.declaration.body,i)}catch(e){if(e instanceof te&&e.type===t.Return)return r&&(s.scope=r),e.value;throw e}return new se}}class ce extends te{constructor(e){super(e,t.List)}get(e){return e.isNumber()?void 0!==this.value[e.value]?this.value[e.value]:new se:e.isRange()?this.range(e):ce.runtime.has(e.value)?ce.runtime.get(e.value):new se}set(e,t){return e.isNumber()&&(this.value[e.value]=t),t}range(e){const t=[];return e.iterate(this.value.length,(e=>{t.push(this.value[e])})),new ce(t)}toString(){return`[${this.value.join(",")}]`}static size(e,t){return new ie(t[0].value.length)}static each(e,t,n){for(let s=0;s<e.value.length;++s)t[0].call(e,[e.value[s],new ie(s),e],n);return e}static sort(e,t,n){const s=e.value;return t.length?s.sort(((s,i)=>t[0].call(e,[s,i],n).value)):s.sort(((e,t)=>e.value-t.value)),e}static map(e,t,n){for(let s=0;s<e.value.length;++s)e.value[s]=t[0].call(e,[new te(e.value[s]),new ie(s),e],n);return e}}ce.runtime=new Map([["concat",we("concat",-1,t.List)],["each",new le("each",1,ce.each)],["sort",new le("sort",-1,ce.sort)],["includes",we("includes",1,t.Boolean)],["indexOf",we("indexOf",1,t.Number)],["join",we("join",1,t.String)],["lastIndexOf",we("lastIndexOf",1,t.Number)],["map",new le("map",1,ce.map)],["pop",we("pop",0,t.List)],["push",we("push",-1,t.List)],["shift",we("shift",0,t.List)],["size",new le("size",0,((e,t)=>new ie(e.value.length)))],["slice",we("slice",-1,t.List)],["splice",we("splice",-1,t.List)],["unshift",we("unshift",-1,t.List)]]);class he extends te{constructor(e){super(e,t.String)}get(e){return e.isNumber()?new he(this.value[e.value]):e.isRange()?this.range(e):he.runtime.has(e.value)?he.runtime.get(e.value):new se}set(e,t){return new se}toString(){return`${this.value}`}range(e){let t="";return e.iterate(this.value.length,(e=>{t+=this.value[e]})),new he(t)}static replace(e,t,n){return t[1].isFunction()?e.value.replace(t[0].value,(s=>t[1].call(e,[new he(s)],n).value)):new he(e.value.replace(t[0].value,t[1].value))}static split(e,t,n){const s=e.value.split(t[0].value).map((e=>new he(e)));return new ce(s)}}he.runtime=new Map([["toUpper",we("toUpperCase",0,t.String)],["toLower",we("toLowerCase",0,t.String)],["size",new le("size",0,((e,t)=>new ie(e.value.length)))],["split",new le("split",1,he.split)],["concat",we("concat",1,t.String)],["includes",we("includes",1,t.Boolean)],["indexOf",we("indexOf",1,t.Number)],["lastIndexOf",we("lastIndexOf",1,t.Number)],["repeat",we("repeat",1,t.String)],["replace",new le("replace",-1,he.replace)],["search",we("search",1,t.Number)],["slice",we("slice",-1,t.String)],["substring",we("substring",-1,t.String)],["trim",we("trim",0,t.String)]]);class pe extends te{constructor(e){super(e,t.Void)}}class me extends te{constructor(e){super(e,t.RegExp)}}class de extends te{constructor(e){super(e,t.Dictionary)}get(e){return this.value.has(e.value)?this.value.get(e.value):de.runtime.has(e.value)?de.runtime.get(e.value):new se}set(e,t){return this.value.set(e.value,t),t}delete(e){const t=this.value.delete(e.value);return new ne(t)}toString(){const e=[];return this.value.forEach(((t,n)=>{e.push(`${n.toString()}: ${t}`)})),`{${e.join("; ")}}`}static each(e,t,n){return e.value.forEach(((s,i)=>{t[0].call(e,[s,new he(i),e],n)})),e}static map(e,t,n){return e.value.forEach(((s,i)=>{e.value.set("key",t[0].call(e,[s,new he(i),e],n))})),e}static indexOf(e,t,n){let s=null;return e.value.forEach(((e,n)=>{e.type===t[0].type&&e.value===t[0].value&&(s=n)})),null!==s?new he(s):new se}}de.runtime=new Map([["clear",we("clear",0,t.Null)],["delete",we("delete",1,t.Boolean)],["each",new le("each",1,de.each)],["has",we("has",1,t.Boolean)],["indexOf",new le("indexOf",1,de.indexOf)],["map",new le("map",1,de.map)],["merge",new le("merge",1,((e,t)=>new de(new Map([...e.value,...t[0].value]))))],["size",new le("size",0,((e,t)=>new ie(e.value.size)))]]);class ve{constructor(e,t,n,s){this.value=e,this.index=t,this.done=n,this.inner=s}}class fe extends te{constructor(e){super(e,t.RegExp),this.iter=new ve(new se,new se,new ne(!1),null)}get(e){return"key"===e.value||"index"===e.value?this.iter.index:"done"===e.value?this.iter.done:"value"===e.value?this.iter.value:fe.runtime.has(e.value)?fe.runtime.get(e.value):new se}complete(){this.iter.done=new ne(!0),this.iter.value=new se,this.iter.index=new se}set(e,t){return void 0!==this.iter[e.value]&&(this.iter[e.value]=t),t}toString(){return`<${t[this.value.type]} iterator>`}static next(e,n,s){const i=e;return i.iter.done.value?i:i.value.isList()?(fe.listNext(e),i):i.value.isDictionary()?(fe.dictionaryNext(e),i):i.value.isString()?(fe.stringNext(e),i):i.value.isNumber()?(fe.numberNext(e),i):i.value.isRange()?(fe.rangeNext(e),i):i.value.isObject()?(e.value.get(s.strings.next).call(e.value,[e],s),i):(s.error(`${t[i.value.type].toLowerCase()} with value ${i.value} is not an iterable`),i.complete(),i)}static listNext(e){const t=e,n=t.value,s=t.iter.index;if(!n.value.length)return t.complete(),t;if(null===t.iter.inner)return t.iter.inner=!0,t.iter.index=new ie(0),t.iter.value=n.value[0],t;if(s.value>=n.value.length-1)return t.complete(),t;const i=s.value+1;return t.iter.index=new ie(i),t.iter.value=n.value[i],t}static stringNext(e){const t=e,n=t.value,s=t.iter.index;if(!n.value.length)return t.complete(),t;if(null===t.iter.inner)return t.iter.inner=!0,t.iter.index=new ie(0),t.iter.value=new he(n.value.charAt(0)),t;if(s.value>=n.value.length-1)return t.complete(),t;const i=s.value+1;return t.iter.index=new ie(i),t.iter.value=new he(n.value.charAt(i)),t}static numberNext(e){const t=e,n=t.value,s=t.iter.index;if(n.value<=0)return t.complete(),t;if(null===t.iter.inner)return t.iter.inner=n.value-1,t.iter.index=new ie(0),t.iter.value=t.iter.index,t;if(s.value>=t.iter.inner)return t.complete(),t;const i=s.value+1;return t.iter.index=new ie(i),t.iter.value=t.iter.index,t}static rangeNext(e){const t=e,n=t.value.value;if(0===n.step||n.start>n.end&&n.step>0||n.start<n.end&&n.step<0)return t.complete(),t;if(null===t.iter.inner)return t.iter.inner=!0,t.iter.index=new ie(0),t.iter.value=new ie(n.start),t;if(n.step>0){if(t.iter.value.value>=n.end)return t.complete(),t}else if(t.iter.value.value<=n.end)return t.complete(),t;const s=t.iter.index.value+1,i=t.iter.value.value+n.step;return t.iter.index=new ie(s),t.iter.value=new ie(i),t}static dictionaryNext(e){const t=e,n=t.value;if(!n.value.size)return t.complete(),t;null===t.iter.inner&&(t.iter.inner=n.value.keys());const s=t.iter.inner.next();return t.iter.value=t.value.get(new te(s.value)),t.iter.index=new he(s.value),s.done&&t.complete(),t}static first(e,t,n){return e.value.value.isList()?new de(new Map([["key",0],["value",e.value.value[0]]])):new se}}function we(e,n,s){return new le(e,n,((n,i)=>{const r=i.map((e=>e.value)),a=n.value[e](...r);switch(s){case t.Boolean:return new ne(a);case t.String:return new he(a);case t.Number:return new ie(a);case t.List:return new ce(a);case t.Null:return new se;default:return new te(a)}}))}function xe(e,t,n){return new le(t,n,((t,n)=>{const s=n.map((e=>e.value)),i=e(...s);return new ie(i)}))}function ge(e,t,n){return new le(t,n,((t,n)=>{const s=n.map((e=>e.value));return e(...s),new pe("void")}))}fe.runtime=new Map([["first",new le("first",0,fe.first)],["next",new le("next",0,fe.next)]]);const Ee={Console:new Map([["log",ge(console.log,"console.log",-1)],["warn",ge(console.warn,"console.warn",-1)],["info",ge(console.info,"console.info",-1)],["error",ge(console.error,"console.error",-1)]]),Math:new Map([["ceil",xe(Math.ceil,"ceil",1)],["cos",xe(Math.cos,"cos",1)],["floor",xe(Math.floor,"floor",1)],["log",xe(Math.log,"log",1)],["max",xe(Math.max,"max",-1)],["min",xe(Math.min,"min",-1)],["pi",new ie(Math.PI)],["pow",xe(Math.pow,"pow",2)],["random",xe(Math.random,"random",0)],["round",xe(Math.round,"round",1)],["sin",xe(Math.sin,"sin",1)],["sqrt",xe(Math.sqrt,"sqrt",1)],["tan",xe(Math.tan,"tan",1)],["trunc",xe(Math.trunc,"trunc",1)]]),Utils:new Map([["re",new le("regex",-1,((e,t)=>{const n=t.map((e=>e.value));return 1===n.length?new me(new RegExp(n[0])):new me(new RegExp(n[0],n[1]))}))],["iter",new le("iter",1,((e,t)=>new fe(t[0])))],["delay",new le("delay",2,((e,t,n)=>(setTimeout((()=>{t[0].call(e,[],n)}),t[1].value),new se)))],["fetch",new le("fetch",2,((e,t,n)=>(fetch(t[0].value).then((e=>e.text())).then((s=>{t[1].call(e,[new he(s)],n)})),new se)))]])};class ye extends te{constructor(e,n,s){super(n,t.Class),this.name=e,this.parent=s}get(e){return this.value.has(e.value)?this.value.get(e.value):this.parent.isClass()?this.parent.get(e):new se}set(e,t){return this.value.set(e.value,t),t}delete(e){const t=this.value.delete(e.value);return new ne(t)}toString(){return`<${this.name} class>`}}class Se extends te{constructor(e,n){super(e,t.Object),this.conztructor=n,this.name=n.name}get(e){const t=this.conztructor.get(e);return t.isFunction()?t:this.value.has(e.value)?this.value.get(e.value):new se}set(e,t){return this.value.set(e.value,t),t}delete(e){const t=this.value.delete(e.value);return new ne(t)}toString(){return`<${this.name} object>`}}class ke{constructor(e,t,n){this.start=e,this.end=t,this.step=n}normalize(e){null===this.step&&(this.step=1),null===this.end&&(this.end=this.step>0?e-1:0),null===this.start&&(this.start=this.step>0?0:e-1)}}class be extends te{constructor(e){super(e,t.Range)}iterate(e,t){if(this.value.normalize(e),this.value.step>0)for(let e=this.value.start;e<=this.value.end;e+=this.value.step)t(e);else if(this.value.step<0)for(let e=this.value.start;e>=this.value.end;e+=this.value.step)t(e);else conzole.warn("[range error] => 0 is not a valid step")}toString(){return`[${this.value.start}:${this.value.end}:${this.value.step}]`}}class Le{constructor(){this.global=new oe,this.scope=this.global,this.errors=[],this.scanner=new o,this.parser=new ae,this.strings={next:new he("next")},this.global.set("math",new de(Ee.Math)),this.global.set("console",new de(Ee.Console)),this.global.set("echo",Ee.Console.get("log")),this.global.set("re",Ee.Utils.get("re")),this.global.set("iter",Ee.Utils.get("iter")),this.global.set("delay",Ee.Utils.get("delay")),this.global.set("fetch",Ee.Utils.get("fetch")),this.parser.errorLevel=0}evaluate(e){return e.result=e.accept(this)}execute(e){return e.result=e.accept(this)}eval(e){try{return{error:!1,value:e.accept(this).toString()}}catch(e){return{error:!0,value:e.message}}}interpet(e){this.errors=[];for(const t of e)try{this.execute(t)}catch(t){if(conzole.error(t.message),this.errors.push(t.message),this.errors.length>100)return this.errors.push("Runtime Error limit exceeded"),e}return e}error(e){throw new Error(`Runtime Error => ${e}`)}visitExpressionStmt(e){return this.evaluate(e.expression)}visitPrintStmt(e){const t=this.evaluate(e.expression);return conzole.log(t.toString()),t}visitVarStmt(e){let t=new se;return null!==e.initializer&&(t=this.evaluate(e.initializer)),t.isLambda()&&(t.name=e.name.lexeme),this.scope.define(e.name.lexeme,t),t}visitVariableExpr(e){return this.scope.get(e.name.lexeme,e.name)}visitPostfixExpr(e){const t=this.scope.get(e.name.lexeme,e.name),n=new ie(t.value+e.increment);return this.scope.assign(e.name.lexeme,n),t}visitListExpr(e){const t=[];for(const n of e.value)if(n instanceof R){const e=this.evaluate(n.value);this.spreadAnyIntoList(e,t)}else if(n instanceof N){const e=this.evaluate(n).value;if(e.step=e.step?e.step:1,e.step>0&&e.start<=e.end)for(let n=e.start;n<=e.end;n+=e.step)t.push(new ie(n));else if(e.step<0&&e.start>=e.end)for(let n=e.start;n>=e.end;n+=e.step)t.push(new ie(n));else this.error(`Invalid range expression at line ${n.line} with range value of [${e.start}:${e.end}:${e.step}]`)}else{const e=this.evaluate(n);t.push(e)}return new ce(t)}spreadAnyIntoList(e,t){const n=new fe(e);for(;!fe.next(n,[],this).iter.done.value;)t.push(n.iter.value)}visitZtringExpr(e){return new he(e.value)}templateParse(e){const t=this.scanner.scan(e),n=this.parser.parse(t);this.parser.errors.length&&this.error(`Template string  error: ${this.parser.errors[0]}`);let s="";for(const e of n)s+=this.execute(e).toString();return s}visitTemplateExpr(e){const t=e.value.replace(/\$\{([\s\S]+?)\}/g,((e,t)=>(";"!==t[t.length]&&(t+=";"),this.templateParse(t))));return new he(t)}visitRegExExpr(e){return new se}visitAssignExpr(e){const t=this.evaluate(e.value);return this.scope.assign(e.name.lexeme,t),t}visitBinaryExpr(t){if(t.left instanceof R&&t.right instanceof R)return this.spreadBinaryExpr(t.left.value,t.right.value,t.operator);const n=this.evaluate(t.left),s=this.evaluate(t.right);switch(t.operator.type){case e.Minus:case e.MinusEqual:return new ie(n.value-s.value);case e.Slash:case e.SlashEqual:return new ie(n.value/s.value);case e.Star:case e.StarEqual:return new ie(n.value*s.value);case e.Percent:case e.PercentEqual:return new ie(n.value%s.value);case e.Plus:case e.PlusEqual:return n.isNumber()&&s.isNumber()?new ie(n.value+s.value):n.isString()&&s.isString()?new he(n.value+s.value):n.isList()&&s.isList()?new ce(n.value.concat(s.value)):n.isDictionary()&&s.isDictionary()?new de(new Map([...n.value,...s.value])):new he(n.toString()+s.toString());case e.Pipe:return new ie(n.value|s.value);case e.Caret:return new ie(n.value^s.value);case e.Greater:return new ne(n.value>s.value);case e.GreaterEqual:return new ne(n.value>=s.value);case e.Less:return new ne(n.value<s.value);case e.LessEqual:return new ne(n.value<=s.value);case e.EqualEqual:return new ne(n.value===s.value);case e.BangEqual:return new ne(n.value!==s.value);case e.LessEqualGreater:return n.value<s.value?new ie(-1):n.value>s.value?new ie(1):new ie(0);default:return this.error("Unknown binary operator "+t.operator),new se}}spreadBinaryExpr(e,t,n){const s=new fe(this.evaluate(e)),i=new fe(this.evaluate(t)),r=[];for(;fe.next(s,[],this),fe.next(i,[],this),!s.iter.done.value&&!i.iter.done.value;){const a=new h(new L(s.iter.value,e.line),n,new L(i.iter.value,t.line),n.line);r.push(this.evaluate(a))}return new ce(r)}visitLogicalExpr(t){const n=this.evaluate(t.left);if(t.operator.type===e.Or){if(n.isTruthy())return n}else if(!n.isTruthy())return n;return this.evaluate(t.right)}visitTernaryExpr(e){return this.evaluate(e.condition).isTruthy()?this.evaluate(e.thenExpr):this.evaluate(e.elseExpr)}visitNullCoalescingExpr(e){const t=this.evaluate(e.left);return t.isNull()?this.evaluate(e.right):t}visitGroupingExpr(e){return this.evaluate(e.expression)}visitLiteralExpr(e){return e.value}visitUnaryExpr(n){const s=this.evaluate(n.right);switch(n.operator.type){case e.Minus:return new ie(-Number(s.value));case e.Bang:return new ne(!s.isTruthy());case e.PlusPlus:case e.MinusMinus:s.isNumber()||this.error(`Invalid right-hand side expression in prefix operation:  "${t[s.type]} ${s} is not a number`);const i=Number(s.value)+(n.operator.type===e.PlusPlus?1:-1);if(n.right instanceof z)this.scope.assign(n.right.name.lexeme,new ie(i));else if(n.right instanceof f){const e=new $(n.right.entity,n.right.key,new L(new ie(i),n.line),n.line);this.evaluate(e)}else this.error(`Invalid right-hand side expression in prefix operation:  ${n.right}`);return new ie(i);default:return this.error("Unknown unary operator ' + expr.operator"),new se}}executeBlock(e,t){const n=this.scope;this.scope=t;for(const t of e)t.result=this.execute(t);return this.scope=n,new pe("block")}visitBlockStmt(e){return this.executeBlock(e.statements,new oe(this.scope))}visitIfStmt(e){return this.evaluate(e.condition).isTruthy()?this.execute(e.thenStmt):null!==e.elseStmt?this.execute(e.elseStmt):new se}visitWhileStmt(e){const n=this.scope;for(;this.evaluate(e.condition).isTruthy();)try{this.execute(e.loop)}catch(e){if(this.scope=n,e instanceof te&&e.type===t.Break)break;if(e instanceof te&&e.type===t.Continue)continue;throw e}return this.scope=n,new pe("while")}visitDoWhileStmt(e){const n=this.scope;do{try{this.execute(e.loop)}catch(e){if(this.scope=n,e instanceof te&&e.type===t.Break)break;if(e instanceof te&&e.type===t.Continue)continue;throw e}}while(this.evaluate(e.condition).isTruthy());return this.scope=n,new pe("dowhile")}visitForStmt(e){const n=this.scope;for(this.scope=new oe(this.scope),this.execute(e.initializer);this.evaluate(e.condition).isTruthy();){const n=this.scope.clone();try{this.executeBlock([e.loop],n),this.evaluate(e.increment)}catch(e){if(e instanceof te&&e.type===t.Break)break;if(e instanceof te&&e.type===t.Continue)continue;throw e}}return this.scope=n,new pe("for")}visitForeachStmt(e){const n=new fe(this.evaluate(e.iterable)),s=this.scope;let i=!1;for(;!fe.next(n,[],this).iter.done.value;){i=!0;const r=new oe(this.scope);r.set(e.name.lexeme,n.iter.value),e.key&&r.set(e.key.lexeme,n.iter.index);try{this.executeBlock([e.loop],r)}catch(e){if(this.scope=s,e instanceof te&&e.type===t.Break)break;if(e instanceof te&&e.type===t.Continue)continue;throw e}}return!i&&e.none&&this.execute(e.none),this.scope=s,new pe("foreach")}visitCallExpr(e){const t=this.evaluate(e.callee);t.isFunction()||this.error(`${t} is not a function`);let n=null;e.callee instanceof f?n=e.callee.entity instanceof c?this.scope.get("this",e.paren):this.evaluate(e.callee.entity):null!==e.thiz&&(n=e.thiz);const s=[];for(const t of e.args)if(t instanceof R){const e=this.evaluate(t.value);this.spreadAnyIntoList(e,s)}else s.push(this.evaluate(t));const i=t;if(s.length!==i.arity&&-1!==i.arity&&(conzole.warn(`Warning at (${e.paren.line}): ${t} mismatched argument count; \n Expected ${i.arity} but got ${s.length} `),s.length<i.arity))for(let e=s.length;e<=i.arity;++e)s.push(new se);return i.call(n,s,this)}visitBaseExpr(e){const t=this.scope.get(e.paren.lexeme,e.paren);t.isObject()||this.error("base expression can be used only inside methods");const n=t.conztructor,s=n.parent;return s.isNull()&&this.error("Class "+n+" has not been extended and has no base"),s}visitNewExpr(t){const n=t.clazz,s=this.evaluate(n.callee);s.isClass()||this.error(`'${s}' is not a class. 'new' statement must be used with classes.`);const i=new Se(new Map,s),r=s.get(new he("constructor"));return r.isFunction()&&this.evaluate(new p(new f(new L(i,t.line),new y(r.declaration.name,t.line),e.Dot,t.line),r.declaration.name,n.args,i,t.line)),i}visitDictionaryExpr(e){const t=new de(new Map);for(const n of e.properties)if(n instanceof R){const e=this.evaluate(n.value),s=new fe(e);for(;!fe.next(s,[],this).iter.done.value;)t.set(s.iter.index,s.iter.value)}else{const e=this.evaluate(n.key),s=this.evaluate(n.value);t.set(e,s)}return t}visitKeyExpr(e){return new te(e.name.literal)}visitGetExpr(t){const n=this.evaluate(t.entity),s=this.evaluate(t.key);return n.isNull()&&t.type===e.QuestionDot?new se:n.get(s)}visitSetExpr(e){const t=this.evaluate(e.entity),n=this.evaluate(e.key),s=this.evaluate(e.value);return t.set(n,s),s.value}visitFuncStmt(e){const t=new ue(e,this.scope);return this.scope.define(e.name.lexeme,t),t}visitClassStmt(e){let t;t=null===e.parent?new se:this.scope.get(e.parent.lexeme,e.parent);const n=new Map;for(const t of e.methods)n.set(t.name.lexeme,new ue(t,this.scope));const s=new ye(e.name.lexeme,n,t);return this.scope.define(e.name.lexeme,s),s}visitLambdaExpr(e){const t=e.lambda;return new ue(t,this.scope)}visitReturnStmt(e){let n=new se;throw e.value&&(n=this.evaluate(e.value)),new te(n,t.Return)}visitBreakStmt(e){throw new te(null,t.Break)}visitContinueStmt(e){throw new te(null,t.Continue)}visitRangeExpr(e){const t=e.start?this.evaluate(e.start).value:null,n=e.end?this.evaluate(e.end).value:null,s=e.step?this.evaluate(e.step).value:t<=n?1:-1;return new be(new ke(t,n,s))}visitTypeofExpr(e){const n=this.evaluate(e.value);return new he(t[n.type].toLowerCase())}visitIsExpr(e){const n=this.evaluate(e.left),s=t[a(e.right.lexeme)];return n.isObject()&&n.name===e.right.lexeme?new ne(!0):void 0===s||isNaN(s)?new ne(!1):new ne(n.type===s)}visitInstanceOfExpr(e){const t=this.evaluate(e.left);if(!t.isObject())return new ne(!1);const n=e.right.lexeme;if("object"===n.toLowerCase())return new ne(!0);let s=t.conztructor;if(s.name===n)return new ne(!0);for(;!s.parent.isNull();)if(s=s.parent,s.name===n)return new ne(!0);return new ne(!1)}visitVoidExpr(e){return this.evaluate(e.value),new se}visitInExpr(e){const n=this.evaluate(e.key),s=this.evaluate(e.entity);return s.isKeyValue()?new ne(s.value.has(n.value)):s.isList()?new ne(void 0!==s.value[n.value]):s.isString()?new ne(s.value.includes(n.value)):(this.error(`Operator "in" can't be used on type ${t[s.type]} with value "${s}"`),new se)}visitCharExpr(e){const t=this.evaluate(e.value);return new he(String.fromCharCode(t.value))}visitSpreadExpr(e){return new se}visitDeleteExpr(e){if(!(e.value instanceof f)){const n=this.evaluate(e.value),s=t[n.type].toLowerCase();return this.error(`Can't delete on type ${s} with value '${n}'. Not a Dictionary, Class or Entity`),new se}const n=e.value,s=this.evaluate(n.entity),i=this.evaluate(n.key);return s.delete(i)}}var Pe;!function(e){e[e.User=0]="User",e[e.Error=1]="Error",e[e.Warning=2]="Warning",e[e.Info=3]="Info"}(Pe||(Pe={}));const Be=new class{constructor(){this.messages=[]}add(e,t){this.messages.push({text:e,time:new Date,type:t})}clear(){this.messages=[]}log(e){this.add(e,Pe.User)}warn(e){this.add(e,Pe.Warning)}error(e){this.add(e,Pe.Error)}info(e){this.add(e,Pe.Info)}first(){return this.messages[0].text}last(){return this.messages[this.messages.length-1].text}print(){return console.log(this.messages.map((e=>e.text)))}},Ce={execute:e=>{const t=new o,n=new ae,s=new Le,i=t.scan(e);if(t.errors.length)return t.errors.forEach((e=>{Be.error(e)})),[];const r=n.parse(i);return n.errors.length?(n.errors.forEach((e=>{Be.error(e)})),[]):s.interpet(r)},interpreter:Le,parser:ae,scanner:o};"undefined"!=typeof window?(window.demoSourceCode="\n// slicing strings\nprint \"one two three four\"[4:7:1]; // prints two\nprint \"hello world\"[::-1]; //prints dlrow olleh\n\n// range operator on list construction\nprint [0:10:3]; // prints a list [0,3,6,9]\nprint [1..5]; // prints [1,2,3,4,5]\n\n// spread operator\nprint {...[1,2,3]}; // prints {0: 1; 1: 2; 2: 3}\nprint ...1..3 == ...1..3; // prints [true,true,true];\nprint ...\"abz\" <=> ...\"ayc\"; // prints [0,-1,1]\n\n\n// functions\nfunction BasicFunction(text) {\n    print text;\n}\nBasicFunction('BasicFunctionArgument');\n\n// classes\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n    hello() {\n        print this.name + ' says hi';\n    }\n}\nclass Student extends Person {\n    constructor(name, grade) {\n        base.constructor(name);\n        this.grade = grade;\n    }\n    hello() {\n        base.hello();\n        print 'from ' + this.grade + ' grade';\n    }\n}\nvar student = new Student('John', 3);\nstudent.hello();\n\n// Recursive function\nfunction factorialize(n) {\n    if (n < 0) {\n        return -1;\n    }\n    if (n == 0) {\n        return 1;\n    }\n    return (n * factorialize(n - 1));\n}\nprint 'factor of 11: ' + factorialize(11);\n// same as factorialize but with ternary\n// and short form function definition\n@factor(n) =>\n    n < 0 ? -1 : (n == 0 ? 1 : (n * factorialize(n - 1)));\nprint 'factor of 11: ' +factor(11);\n\n// nested function returns function\n@add(a) => @(b) => @(c) => a + b + c;\nprint add(100)(20)(3);\n\n// literals\nvar literal = {\n    firstname: \"John\",\n    lastname: \"Doe\",\n    records: {\n        prev: \"previous\",\n        next: \"next\"\n    }\n};\nprint literal.records.prev;\n\n// safe navigator operator ?.\nprint literal.safeNavigator?.propertyDoesNotExist;\n\n// delete operator\ndelete literal.firstname;\n\n// new scope test\n{\n    var a = {a: 'one'};\n    var b = {b: 'two'};\n    var c = a + b;\n    print c; // prints {a: 'one', b: 'two'}\n}\n// new scope test\n{\n    var a = {d: 'three'};\n    var b = {e: 'four'};\n    var c = a + b;\n    print c; // prints {d: 'three', e: 'four'}\n}\n\n// typeof, is, instanceof operator\nprint typeof Person;\nprint typeof student;\nprint 'Student is Class: ' + (Student is Class);\nprint 'student is Object: ' + (student is Object);\nprint 'student is Person: ' + (student is Person);\nprint 'student is Student: ' + (student is Student);\nprint 'student instanceof Person: ' + (student instanceof Person);\nprint typeof '' + 'string';\n\n// iterators\nvar it = iter(['one', 'two', 'three']);\nwhile (!it.next().done) {\n    print it.value;\n}\n\n// foreach statement\nforeach (item with key in ['one', 'two', 'three']) {\n    print item;\n}\n\n// foreach statement with none\nforeach (item  in []) {\n    print item;\n} none {\n    print \"no items\";\n}\n\n// spread operator\n{\n    var a1 = ['one', 'two', 'three'];\n    var b2 = [...a1, ...\"spreading\"];\n    var d3 = {\n        ...a1,\n        ...\"spreding\"\n    };\n    print b2;\n    print d3;\n}\n\n// loggin into js console\necho ('execution finished');\n\n// fetching data. Currently unparsed text\nfetch ('https://jsonplaceholder.typicode.com/todos/1', @(res) {\n    echo(res);\n});\n",window.atscript=Ce,window.conzole=Be):(n.g.conzole=Be,exports.atscript=Ce)})();
//# sourceMappingURL=atscript.min.js.map