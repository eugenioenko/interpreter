{"version":3,"file":"atscript.min.js","mappings":"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","sources":["webpack://interpreter/webpack/bootstrap","webpack://interpreter/./src/token.ts","webpack://interpreter/./src/types/type.enum.ts","webpack://interpreter/webpack/runtime/global","webpack://interpreter/./src/utils.ts","webpack://interpreter/./src/scanner.ts","webpack://interpreter/./src/types/expression.ts","webpack://interpreter/./src/types/statement.ts","webpack://interpreter/./src/types/any.ts","webpack://interpreter/./src/types/boolean.ts","webpack://interpreter/./src/types/null.ts","webpack://interpreter/./src/types/number.ts","webpack://interpreter/./src/types/error.ts","webpack://interpreter/./src/parser.ts","webpack://interpreter/./src/scope.ts","webpack://interpreter/./src/types/function.ts","webpack://interpreter/./src/types/list.ts","webpack://interpreter/./src/types/string.ts","webpack://interpreter/./src/types/void.ts","webpack://interpreter/./src/types/regex.ts","webpack://interpreter/./src/types/dictionary.ts","webpack://interpreter/./src/types/iterator.ts","webpack://interpreter/./src/runtime.ts","webpack://interpreter/./src/types/class.ts","webpack://interpreter/./src/types/object.ts","webpack://interpreter/./src/types/range.ts","webpack://interpreter/./src/interpreter.ts","webpack://interpreter/./src/console.ts","webpack://interpreter/./src/demos/demo.ts","webpack://interpreter/./src/atscript.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","export enum TokenType {\n    // Parser Tokens\n    Eof,\n    Panic,\n    Lambda,\n\n    // Single Character Tokens\n    Ampersand,\n    AtSign,\n    Caret,\n    Comma,\n    Dollar,\n    Dot,\n    Hash,\n    LeftBrace,\n    LeftBracket,\n    LeftParen,\n    Percent,\n    Pipe,\n    RightBrace,\n    RightBracket,\n    RightParen,\n    Semicolon,\n    Slash,\n    Star,\n\n    // One Or Two Character Tokens\n    Arrow,\n    Bang,\n    BangEqual,\n    Colon,\n    Equal,\n    EqualEqual,\n    Greater,\n    GreaterEqual,\n    Less,\n    LessEqual,\n    Minus,\n    MinusEqual,\n    MinusMinus,\n    PercentEqual,\n    Plus,\n    PlusEqual,\n    PlusPlus,\n    Question,\n    QuestionDot,\n    QuestionQuestion,\n    SlashEqual,\n    StarEqual,\n    DotDot,\n    DotDotDot,\n    LessEqualGreater,\n\n    // Literals\n    Identifier,\n    Template,\n    String,\n    Number,\n    Regex,\n\n    // Keywords\n    And,\n    Break,\n    Base,\n    Class,\n    Continue,\n    Delete,\n    Do,\n    Else,\n    Extends,\n    False,\n    For,\n    Foreach,\n    Function,\n    If,\n    In,\n    Instanceof,\n    Is,\n    New,\n    None,\n    Null,\n    Or,\n    Print,\n    Return,\n    True,\n    Typeof,\n    Var,\n    Void,\n    While,\n    With,\n}\n\nexport class Token {\n    public name: string;\n    public line: number;\n    public col: number;\n    public type: TokenType;\n    public literal: any;\n    public lexeme: string;\n\n    constructor(\n        type: TokenType,\n        lexeme: string,\n        literal: any,\n        line: number,\n        col: number\n    ) {\n        this.name = TokenType[type];\n        this.type = type;\n        this.lexeme = lexeme;\n        this.literal = literal;\n        this.line = line;\n        this.col = col;\n    }\n\n    public toString() {\n        return `[(${this.line}):\"${this.lexeme}\"]`;\n    }\n}\n","export enum DataType {\n    Null,    // 0\n    Any,     // 1\n    Boolean, // 2\n    Number,  // 3\n    String,  // 4\n    List,    // 5\n    Dictionary, // 6\n    Object,   // 7\n    Class,    // 8\n    Function, // 9\n    Lambda,   // 10\n    Range,    // 11\n    RegExp,   // 12\n    Error,    // 13\n    Iterator, // 14\n    // internal types\n    Void = 100, //  100\n    Return,   // 101\n    Break,    // 102\n    Continue  // 103\n}\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","import { TokenType } from \"./token\";\n\nexport function isDigit(char: string): boolean {\n    return char >= \"0\" && char <= \"9\";\n}\n\nexport function isAlpha(char: string): boolean {\n    return (char >= \"a\" && char <= \"z\") || (char >= \"A\" && char <= \"Z\");\n}\n\nexport function isAlphaNumeric(char: string): boolean {\n    return isAlpha(char) || isDigit(char);\n}\n\nexport function isKeyword(word: string): boolean {\n    return (TokenType[word as never] as never) >= TokenType.And;\n}\n\nexport function capitalize(word: string): string {\n    return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();\n}\n","import { Token, TokenType } from \"./token\";\nimport { Console } from \"./console\";\nimport * as Utils from \"./utils\";\nimport { $Error } from \"./types/error\";\ndeclare var conzole: Console;\n\nexport class Scanner {\n    /** scripts source code */\n    public source: string;\n    /** containes the source code represented as list of tokens */\n    public tokens: Token[];\n    /** List of errors from scanning */\n    public errors: string[];\n    /** points to the current character being tokenized */\n    private current: number;\n    /** points to the start of the token frase */\n    private start: number;\n    /** current line of source code bieng tokenized */\n    private line: number;\n    /** current column of the character being tokenized */\n    private col: number;\n\n    public scan(source: string): Token[] {\n        this.source = source;\n        this.tokens = [];\n        this.errors = [];\n        this.current = 0;\n        this.start = 0;\n        this.line = 1;\n        this.col = 1;\n\n        while (!this.eof()) {\n            this.start = this.current;\n            try {\n                this.getToken();\n            } catch (e: any) {\n                this.errors.push(e.message);\n                if (this.errors.length > 100) {\n                    this.errors.push(\"Error limit exceeded\");\n                    return this.tokens;\n                }\n            }\n        }\n        this.tokens.push(new Token(TokenType.Eof, \"\", null, this.line, 0));\n        return this.tokens;\n    }\n\n    private eof(): boolean {\n        return this.current >= this.source.length;\n    }\n\n    private advance(): string {\n        if (this.peek() === \"\\n\") {\n            this.line++;\n            this.col = 0;\n        }\n        this.current++;\n        this.col++;\n        return this.source.charAt(this.current - 1);\n    }\n\n    private addToken(tokenType: TokenType, literal: any): void {\n        const text = this.source.substring(this.start, this.current);\n        this.tokens.push(\n            new Token(tokenType, text, literal, this.line, this.col)\n        );\n    }\n\n    private match(expected: string): boolean {\n        if (this.eof()) {\n            return false;\n        }\n\n        if (this.source.charAt(this.current) !== expected) {\n            return false;\n        }\n\n        this.current++;\n        return true;\n    }\n\n    private peek(): string {\n        if (this.eof()) {\n            return \"\\0\";\n        }\n        return this.source.charAt(this.current);\n    }\n\n    private peekNext(): string {\n        if (this.current + 1 >= this.source.length) {\n            return \"\\0\";\n        }\n        return this.source.charAt(this.current + 1);\n    }\n\n    private comment(): void {\n        while (this.peek() !== \"\\n\" && !this.eof()) {\n            this.advance();\n        }\n    }\n\n    private multilineComment(): void {\n        while (\n            !this.eof() &&\n            !(this.peek() === \"*\" && this.peekNext() === \"/\")\n        ) {\n            this.advance();\n        }\n        if (this.eof()) {\n            this.error('Unterminated comment, expecting closing \"*/\"');\n        } else {\n            // the closing slash '*/'\n            this.advance();\n            this.advance();\n        }\n    }\n\n    private string(quote: string): void {\n        while (this.peek() !== quote && !this.eof()) {\n            this.advance();\n        }\n\n        // Unterminated string.\n        if (this.eof()) {\n            this.error(`Unterminated string, expecting closing ${quote}`);\n            return;\n        }\n\n        // The closing \".\n        this.advance();\n\n        // Trim the surrounding quotes.\n        const value = this.source.substring(this.start + 1, this.current - 1);\n        this.addToken(\n            quote !== \"`\" ? TokenType.String : TokenType.Template,\n            value\n        );\n    }\n\n    private number(): void {\n        // gets integer part\n        while (Utils.isDigit(this.peek())) {\n            this.advance();\n        }\n\n        // checks for fraction\n        if (this.peek() === \".\" && Utils.isDigit(this.peekNext())) {\n            this.advance();\n        }\n\n        // gets fraction part\n        while (Utils.isDigit(this.peek())) {\n            this.advance();\n        }\n\n        // checks for exponent\n        if (this.peek().toLowerCase() === \"e\") {\n            this.advance();\n            if (this.peek() === \"-\" || this.peek() === \"+\") {\n                this.advance();\n            }\n        }\n\n        while (Utils.isDigit(this.peek())) {\n            this.advance();\n        }\n\n        const value = this.source.substring(this.start, this.current);\n        this.addToken(TokenType.Number, Number(value));\n    }\n\n    private identifier(): void {\n        while (Utils.isAlphaNumeric(this.peek())) {\n            this.advance();\n        }\n\n        const value = this.source.substring(this.start, this.current);\n        const capitalized = Utils.capitalize(value);\n        if (Utils.isKeyword(capitalized)) {\n            this.addToken(TokenType[capitalized as never] as any, value);\n        } else {\n            this.addToken(TokenType.Identifier, value);\n        }\n    }\n\n    private getToken(): void {\n        const char = this.advance();\n        switch (char) {\n            case \"(\":\n                this.addToken(TokenType.LeftParen, null);\n                break;\n            case \")\":\n                this.addToken(TokenType.RightParen, null);\n                break;\n            case \"[\":\n                this.addToken(TokenType.LeftBracket, null);\n                break;\n            case \"]\":\n                this.addToken(TokenType.RightBracket, null);\n                break;\n            case \"{\":\n                this.addToken(TokenType.LeftBrace, null);\n                break;\n            case \"}\":\n                this.addToken(TokenType.RightBrace, null);\n                break;\n            case \",\":\n                this.addToken(TokenType.Comma, null);\n                break;\n            case \";\":\n                this.addToken(TokenType.Semicolon, null);\n                break;\n            case \"^\":\n                this.addToken(TokenType.Caret, null);\n                break;\n            case \"$\":\n                this.addToken(TokenType.Dollar, null);\n                break;\n            case \"#\":\n                this.addToken(TokenType.Hash, null);\n                break;\n            case \"@\":\n                this.addToken(TokenType.Function, \"@\");\n                break;\n            case \":\":\n                this.addToken(\n                    this.match(\"=\") ? TokenType.Arrow : TokenType.Colon,\n                    null\n                );\n                break;\n            case \"*\":\n                this.addToken(\n                    this.match(\"=\") ? TokenType.StarEqual : TokenType.Star,\n                    null\n                );\n                break;\n            case \"%\":\n                this.addToken(\n                    this.match(\"=\")\n                        ? TokenType.PercentEqual\n                        : TokenType.Percent,\n                    null\n                );\n                break;\n            case \"|\":\n                this.addToken(\n                    this.match(\"|\") ? TokenType.Or : TokenType.Pipe,\n                    null\n                );\n                break;\n            case \"&\":\n                this.addToken(\n                    this.match(\"&\") ? TokenType.And : TokenType.Ampersand,\n                    null\n                );\n                break;\n            case \">\":\n                this.addToken(\n                    this.match(\"=\")\n                        ? TokenType.GreaterEqual\n                        : TokenType.Greater,\n                    null\n                );\n                break;\n            case \"!\":\n                this.addToken(\n                    this.match(\"=\") ? TokenType.BangEqual : TokenType.Bang,\n                    null\n                );\n                break;\n            case \"?\":\n                this.addToken(\n                    this.match(\"?\")\n                        ? TokenType.QuestionQuestion\n                        : this.match(\".\")\n                        ? TokenType.QuestionDot\n                        : TokenType.Question,\n                    null\n                );\n                break;\n            case \"=\":\n                this.addToken(\n                    this.match(\"=\")\n                        ? TokenType.EqualEqual\n                        : this.match(\">\")\n                        ? TokenType.Arrow\n                        : TokenType.Equal,\n                    null\n                );\n                break;\n            case \"+\":\n                this.addToken(\n                    this.match(\"+\")\n                        ? TokenType.PlusPlus\n                        : this.match(\"=\")\n                        ? TokenType.PlusEqual\n                        : TokenType.Plus,\n                    null\n                );\n                break;\n            case \"-\":\n                this.addToken(\n                    this.match(\"-\")\n                        ? TokenType.MinusMinus\n                        : this.match(\">\")\n                        ? TokenType.Return\n                        : this.match(\"=\")\n                        ? TokenType.MinusEqual\n                        : TokenType.Minus,\n                    null\n                );\n                break;\n            case \"<\":\n                this.addToken(\n                    this.match(\"=\")\n                        ? this.match(\">\")\n                            ? TokenType.LessEqualGreater\n                            : TokenType.LessEqual\n                        : TokenType.Less,\n                    null\n                );\n                break;\n            case \".\":\n                if (this.match(\".\")) {\n                    if (this.match(\".\")) {\n                        this.addToken(TokenType.DotDotDot, null);\n                    } else {\n                        this.addToken(TokenType.DotDot, null);\n                    }\n                } else {\n                    this.addToken(TokenType.Dot, null);\n                }\n                break;\n            case \"/\":\n                if (this.match(\"/\")) {\n                    this.comment();\n                } else if (this.match(\"*\")) {\n                    this.multilineComment();\n                } else {\n                    this.addToken(\n                        this.match(\"=\")\n                            ? TokenType.SlashEqual\n                            : TokenType.Slash,\n                        null\n                    );\n                }\n                break;\n            case `'`:\n            case `\"`:\n            case \"`\":\n                this.string(char);\n                break;\n            // ignore cases\n            case \"\\n\":\n            case \" \":\n            case \"\\r\":\n            case \"\\t\":\n                break;\n            // compex cases\n            default:\n                if (Utils.isDigit(char)) {\n                    this.number();\n                } else if (Utils.isAlpha(char)) {\n                    this.identifier();\n                } else {\n                    this.error(`Unexpected character '${char}'`);\n                }\n                break;\n        }\n    }\n\n    private error(message: string): void {\n        throw new Error(`Scan Error (${this.line}:${this.col}) => ${message}`);\n    }\n}\n","import { Token, TokenType } from 'token';\nimport { Stmt } from 'statement';\nimport { $Any } from 'any';\n\nexport abstract class Expr {\n    public result: any;\n    public line: number;\n    // tslint:disable-next-line\n    constructor() { }\n    public abstract accept<R>(visitor: ExprVisitor<R>): R;\n}\n\n// tslint:disable-next-line\nexport interface ExprVisitor<R> {\n    visitAssignExpr(expr: Assign): R;\n    visitBaseExpr(expr: Base): R;\n    visitBinaryExpr(expr: Binary): R;\n    visitCallExpr(expr: Call): R;\n    visitCharExpr(expr: Char): R;\n    visitDeleteExpr(expr: Delete): R;\n    visitDictionaryExpr(expr: Dictionary): R;\n    visitGetExpr(expr: Get): R;\n    visitGroupingExpr(expr: Grouping): R;\n    visitInExpr(expr: In): R;\n    visitInstanceOfExpr(expr: InstanceOf): R;\n    visitIsExpr(expr: Is): R;\n    visitKeyExpr(expr: Key): R;\n    visitLambdaExpr(expr: Lambda): R;\n    visitLogicalExpr(expr: Logical): R;\n    visitListExpr(expr: List): R;\n    visitLiteralExpr(expr: Literal): R;\n    visitNewExpr(expr: New): R;\n    visitNullCoalescingExpr(expr: NullCoalescing): R;\n    visitPostfixExpr(expr: Postfix): R;\n    visitRangeExpr(expr: Range): R;\n    visitRegExExpr(expr: RegEx): R;\n    visitSetExpr(expr: Set): R;\n    visitSpreadExpr(expr: Spread): R;\n    visitTemplateExpr(expr: Template): R;\n    visitTernaryExpr(expr: Ternary): R;\n    visitTypeofExpr(expr: Typeof): R;\n    visitUnaryExpr(expr: Unary): R;\n    visitVariableExpr(expr: Variable): R;\n    visitVoidExpr(expr: Void): R;\n    visitZtringExpr(expr: Ztring): R;\n}\n\nexport class Assign extends Expr {\n    public name: Token;\n    public value: Expr;\n\n    constructor(name: Token, value: Expr, line: number) {\n        super();\n        this.name = name;\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitAssignExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Assign';\n    }\n}\n\nexport class Base extends Expr {\n    public paren: Token;\n\n    constructor(paren: Token, line: number) {\n        super();\n        this.paren = paren;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitBaseExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Base';\n    }\n}\n\nexport class Binary extends Expr {\n    public left: Expr;\n    public operator: Token;\n    public right: Expr;\n\n    constructor(left: Expr, operator: Token, right: Expr, line: number) {\n        super();\n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitBinaryExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Binary';\n    }\n}\n\nexport class Call extends Expr {\n    public callee: Expr;\n    public paren: Token;\n    public args: Expr[];\n    public thiz: $Any;\n\n    constructor(callee: Expr, paren: Token, args: Expr[], thiz: $Any, line: number) {\n        super();\n        this.callee = callee;\n        this.paren = paren;\n        this.args = args;\n        this.thiz = thiz;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitCallExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Call';\n    }\n}\n\nexport class Char extends Expr {\n    public value: Expr;\n\n    constructor(value: Expr, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitCharExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Char';\n    }\n}\n\nexport class Delete extends Expr {\n    public value: Expr;\n\n    constructor(value: Expr, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitDeleteExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Delete';\n    }\n}\n\nexport class Dictionary extends Expr {\n    public properties: Expr[];\n\n    constructor(properties: Expr[], line: number) {\n        super();\n        this.properties = properties;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitDictionaryExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Dictionary';\n    }\n}\n\nexport class Get extends Expr {\n    public entity: Expr;\n    public key: Expr;\n    public type: TokenType;\n\n    constructor(entity: Expr, key: Expr, type: TokenType, line: number) {\n        super();\n        this.entity = entity;\n        this.key = key;\n        this.type = type;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitGetExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Get';\n    }\n}\n\nexport class Grouping extends Expr {\n    public expression: Expr;\n\n    constructor(expression: Expr, line: number) {\n        super();\n        this.expression = expression;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitGroupingExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Grouping';\n    }\n}\n\nexport class In extends Expr {\n    public key: Expr;\n    public entity: Expr;\n\n    constructor(key: Expr, entity: Expr, line: number) {\n        super();\n        this.key = key;\n        this.entity = entity;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitInExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.In';\n    }\n}\n\nexport class InstanceOf extends Expr {\n    public left: Expr;\n    public right: Token;\n\n    constructor(left: Expr, right: Token, line: number) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitInstanceOfExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.InstanceOf';\n    }\n}\n\nexport class Is extends Expr {\n    public left: Expr;\n    public right: Token;\n\n    constructor(left: Expr, right: Token, line: number) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitIsExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Is';\n    }\n}\n\nexport class Key extends Expr {\n    public name: Token;\n\n    constructor(name: Token, line: number) {\n        super();\n        this.name = name;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitKeyExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Key';\n    }\n}\n\nexport class Lambda extends Expr {\n    public lambda: Stmt;\n\n    constructor(lambda: Stmt, line: number) {\n        super();\n        this.lambda = lambda;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitLambdaExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Lambda';\n    }\n}\n\nexport class Logical extends Expr {\n    public left: Expr;\n    public operator: Token;\n    public right: Expr;\n\n    constructor(left: Expr, operator: Token, right: Expr, line: number) {\n        super();\n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitLogicalExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Logical';\n    }\n}\n\nexport class List extends Expr {\n    public value: Expr[];\n\n    constructor(value: Expr[], line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitListExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.List';\n    }\n}\n\nexport class Literal extends Expr {\n    public value: $Any;\n\n    constructor(value: $Any, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitLiteralExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Literal';\n    }\n}\n\nexport class New extends Expr {\n    public clazz: Expr;\n\n    constructor(clazz: Expr, line: number) {\n        super();\n        this.clazz = clazz;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitNewExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.New';\n    }\n}\n\nexport class NullCoalescing extends Expr {\n    public left: Expr;\n    public right: Expr;\n\n    constructor(left: Expr, right: Expr, line: number) {\n        super();\n        this.left = left;\n        this.right = right;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitNullCoalescingExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.NullCoalescing';\n    }\n}\n\nexport class Postfix extends Expr {\n    public name: Token;\n    public increment: number;\n\n    constructor(name: Token, increment: number, line: number) {\n        super();\n        this.name = name;\n        this.increment = increment;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitPostfixExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Postfix';\n    }\n}\n\nexport class Range extends Expr {\n    public start: Expr;\n    public end: Expr;\n    public step: Expr;\n\n    constructor(start: Expr, end: Expr, step: Expr, line: number) {\n        super();\n        this.start = start;\n        this.end = end;\n        this.step = step;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitRangeExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Range';\n    }\n}\n\nexport class RegEx extends Expr {\n    public value: RegExp;\n\n    constructor(value: RegExp, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitRegExExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.RegEx';\n    }\n}\n\nexport class Set extends Expr {\n    public entity: Expr;\n    public key: Expr;\n    public value: Expr;\n\n    constructor(entity: Expr, key: Expr, value: Expr, line: number) {\n        super();\n        this.entity = entity;\n        this.key = key;\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitSetExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Set';\n    }\n}\n\nexport class Spread extends Expr {\n    public value: Expr;\n\n    constructor(value: Expr, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitSpreadExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Spread';\n    }\n}\n\nexport class Template extends Expr {\n    public value: string;\n\n    constructor(value: string, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitTemplateExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Template';\n    }\n}\n\nexport class Ternary extends Expr {\n    public condition: Expr;\n    public thenExpr: Expr;\n    public elseExpr: Expr;\n\n    constructor(condition: Expr, thenExpr: Expr, elseExpr: Expr, line: number) {\n        super();\n        this.condition = condition;\n        this.thenExpr = thenExpr;\n        this.elseExpr = elseExpr;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitTernaryExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Ternary';\n    }\n}\n\nexport class Typeof extends Expr {\n    public value: Expr;\n\n    constructor(value: Expr, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitTypeofExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Typeof';\n    }\n}\n\nexport class Unary extends Expr {\n    public operator: Token;\n    public right: Expr;\n\n    constructor(operator: Token, right: Expr, line: number) {\n        super();\n        this.operator = operator;\n        this.right = right;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitUnaryExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Unary';\n    }\n}\n\nexport class Variable extends Expr {\n    public name: Token;\n\n    constructor(name: Token, line: number) {\n        super();\n        this.name = name;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitVariableExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Variable';\n    }\n}\n\nexport class Void extends Expr {\n    public value: Expr;\n\n    constructor(value: Expr, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitVoidExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Void';\n    }\n}\n\nexport class Ztring extends Expr {\n    public value: string;\n\n    constructor(value: string, line: number) {\n        super();\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: ExprVisitor<R>): R {\n        return visitor.visitZtringExpr(this);\n    }\n\n    public toString(): string {\n        return 'Expr.Ztring';\n    }\n}\n\n","import { Token } from 'token';\n\nimport { Expr } from 'expression';\n\nexport abstract class Stmt {\n    public result: any;\n    public line: number;\n    // tslint:disable-next-line\n    constructor() { }\n    public abstract accept<R>(visitor: StmtVisitor<R>): R;\n}\n\n// tslint:disable-next-line\nexport interface StmtVisitor<R> {\n    visitBlockStmt(stmt: Block): R;\n    visitBreakStmt(stmt: Break): R;\n    visitClassStmt(stmt: Class): R;\n    visitContinueStmt(stmt: Continue): R;\n    visitDoWhileStmt(stmt: DoWhile): R;\n    visitExpressionStmt(stmt: Expression): R;\n    visitForeachStmt(stmt: Foreach): R;\n    visitFuncStmt(stmt: Func): R;\n    visitIfStmt(stmt: If): R;\n    visitPrintStmt(stmt: Print): R;\n    visitReturnStmt(stmt: Return): R;\n    visitVarStmt(stmt: Var): R;\n    visitWhileStmt(stmt: While): R;\n}\n\nexport class Block extends Stmt {\n    public statements: Stmt[];\n\n    constructor(statements: Stmt[], line: number) {\n        super();\n        this.statements = statements;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitBlockStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Block';\n    }\n}\n\nexport class Break extends Stmt {\n    public keyword: Token;\n\n    constructor(keyword: Token, line: number) {\n        super();\n        this.keyword = keyword;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitBreakStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Break';\n    }\n}\n\nexport class Class extends Stmt {\n    public name: Token;\n    public parent: Token;\n    public methods: Func[];\n\n    constructor(name: Token, parent: Token, methods: Func[], line: number) {\n        super();\n        this.name = name;\n        this.parent = parent;\n        this.methods = methods;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitClassStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Class';\n    }\n}\n\nexport class Continue extends Stmt {\n    public keyword: Token;\n\n    constructor(keyword: Token, line: number) {\n        super();\n        this.keyword = keyword;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitContinueStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Continue';\n    }\n}\n\nexport class DoWhile extends Stmt {\n    public loop: Stmt;\n    public condition: Expr;\n\n    constructor(loop: Stmt, condition: Expr, line: number) {\n        super();\n        this.loop = loop;\n        this.condition = condition;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitDoWhileStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.DoWhile';\n    }\n}\n\nexport class Expression extends Stmt {\n    public expression: Expr;\n\n    constructor(expression: Expr, line: number) {\n        super();\n        this.expression = expression;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitExpressionStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Expression';\n    }\n}\n\nexport class Foreach extends Stmt {\n    public name: Token;\n    public key: Token;\n    public iterable: Expr;\n    public loop: Stmt;\n    public none: Stmt;\n\n    constructor(name: Token, key: Token, iterable: Expr, loop: Stmt, none: Stmt, line: number) {\n        super();\n        this.name = name;\n        this.key = key;\n        this.iterable = iterable;\n        this.loop = loop;\n        this.none = none;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitForeachStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Foreach';\n    }\n}\n\nexport class Func extends Stmt {\n    public name: Token;\n    public params: Token[];\n    public body: Stmt[];\n\n    constructor(name: Token, params: Token[], body: Stmt[], line: number) {\n        super();\n        this.name = name;\n        this.params = params;\n        this.body = body;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitFuncStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Func';\n    }\n}\n\nexport class If extends Stmt {\n    public condition: Expr;\n    public thenStmt: Stmt;\n    public elseStmt: Stmt;\n\n    constructor(condition: Expr, thenStmt: Stmt, elseStmt: Stmt, line: number) {\n        super();\n        this.condition = condition;\n        this.thenStmt = thenStmt;\n        this.elseStmt = elseStmt;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitIfStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.If';\n    }\n}\n\nexport class Print extends Stmt {\n    public expression: Expr;\n\n    constructor(expression: Expr, line: number) {\n        super();\n        this.expression = expression;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitPrintStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Print';\n    }\n}\n\nexport class Return extends Stmt {\n    public keyword: Token;\n    public value: Expr;\n\n    constructor(keyword: Token, value: Expr, line: number) {\n        super();\n        this.keyword = keyword;\n        this.value = value;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitReturnStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Return';\n    }\n}\n\nexport class Var extends Stmt {\n    public name: Token;\n    public type: Token;\n    public initializer: Expr;\n\n    constructor(name: Token, type: Token, initializer: Expr, line: number) {\n        super();\n        this.name = name;\n        this.type = type;\n        this.initializer = initializer;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitVarStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.Var';\n    }\n}\n\nexport class While extends Stmt {\n    public condition: Expr;\n    public loop: Stmt;\n\n    constructor(condition: Expr, loop: Stmt, line: number) {\n        super();\n        this.condition = condition;\n        this.loop = loop;\n        this.line = line;\n    }\n\n    public accept<R>(visitor: StmtVisitor<R>): R {\n        return visitor.visitWhileStmt(this);\n    }\n\n    public toString(): string {\n        return 'Stmt.While';\n    }\n}\n\n","import { Console } from '../console';\nimport { DataType } from './type.enum';\ndeclare var conzole: Console;\n\nexport class $Any {\n\n    public value: any;\n    public type = DataType.Any;\n\n    constructor(value: any, type: DataType = DataType.Any) {\n        this.value = value;\n        this.type = type;\n    }\n\n    public isString(): boolean {\n        return this.type === DataType.String;\n    }\n\n    public isNull(): boolean {\n        return this.type === DataType.Null;\n    }\n\n    public isBoolean(): boolean {\n        return this.type === DataType.Boolean;\n    }\n\n    public isNumber(): boolean {\n        return this.type === DataType.Number;\n    }\n\n    public isRange(): boolean {\n        return this.type === DataType.Range;\n    }\n\n    public isFunction(): boolean {\n        return this.type === DataType.Function;\n    }\n\n    public isClass(): boolean {\n        return this.type === DataType.Class;\n    }\n\n    public isLambda(): boolean {\n        return this.type === DataType.Function && (this as any).name === '@';\n    }\n\n    public isList(): boolean {\n        return this.type === DataType.List;\n    }\n\n    public isDictionary(): boolean {\n        return this.type === DataType.Dictionary;\n    }\n\n    public isObject(): boolean {\n        return this.type === DataType.Object;\n    }\n\n    public isTruthy(): boolean {\n        if (this.isNull()) {\n            return false;\n        }\n        if (this.isBoolean()) {\n            return Boolean(this.value);\n        }\n        if (this.isNumber() && this.value === 0) {\n            return false;\n        }\n        if (this.isString() && this.value.toString().length === 0) {\n            return false;\n        }\n        if (this.isList() && this.value.length === 0) {\n            return false;\n        }\n        if (this.isDictionary() && this.value.size === 0) {\n            return false;\n        }\n        if (this.value === null) {\n            throw new Error(\"Unknown error value Any is null\");\n        }\n        if (typeof this.value === 'undefined') {\n            throw new Error(\"Unknown error value Any is undefined\");\n        }\n        return true;\n    }\n\n    public isEqual(other: $Any): boolean {\n        return this.value === other.value;\n    }\n\n    public isKeyValue(): boolean {\n        if (this.type === DataType.Class ||\n            this.type === DataType.Dictionary ||\n            this.type === DataType.Object\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    public get(key: $Any): $Any {\n        conzole.error(`key ${key} does not exist in ${this}`);\n        throw new Error(\"Error in Any getter\");\n    }\n\n    public set(key: $Any, value: $Any): $Any {\n        conzole.error(`key ${key} does not exist in ${this}`);\n        throw new Error(\"Error in Any setter\");\n    }\n\n    public delete(key: $Any): $Any {\n        conzole.error(`${this} does not support operator`);\n        throw new Error(\"Error in Any delete\");\n    }\n\n    public toString(): string {\n        return this.value.toString();\n    }\n}\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\n\nexport class $Boolean extends $Any {\n\n    public value: boolean;\n\n    constructor(value: boolean) {\n        super(value, DataType.Boolean);\n    }\n\n}\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\n\nexport class $Null extends $Any {\n\n    public value: boolean;\n\n    constructor() {\n        super(null);\n        this.type = DataType.Null;\n    }\n\n    public toString() {\n        return 'null';\n    }\n\n}\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\n\nexport class $Number extends $Any {\n\n    public value: number;\n\n    constructor(value: number) {\n        super(value, DataType.Number);\n    }\n\n    public toString(): string {\n        return this.value.toString();\n    }\n\n}\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\n\nexport class $Error extends $Any {\n\n    public value: string;\n    public line: number;\n    public col: number;\n\n    constructor(value: string, line: number, col: number) {\n        super(value, DataType.Error);\n        this.line = line;\n        this.col = col;\n    }\n\n    public toString(): string {\n        return this.value.toString();\n    }\n\n}\n","import * as Expr from \"./types/expression\";\nimport * as Stmt from \"./types/statement\";\nimport { Console } from \"./console\";\nimport { Token, TokenType } from \"./token\";\nimport { $Boolean } from \"./types/boolean\";\nimport { $Null } from \"./types/null\";\nimport { $Number } from \"./types/number\";\nimport { $Error } from \"./types/error\";\ndeclare var conzole: Console;\n\nexport class Parser {\n    private current: number;\n    private tokens: Token[];\n    public errors: string[];\n    public errorLevel = 1;\n\n    public parse(tokens: Token[]): Stmt.Stmt[] {\n        this.current = 0;\n        this.tokens = tokens;\n        this.errors = [];\n        const statements: Stmt.Stmt[] = [];\n        while (!this.eof()) {\n            try {\n                statements.push(this.declaration());\n            } catch (e: any) {\n                if (e instanceof $Error) {\n                    this.errors.push(\n                        `Parse Error (${e.line}:${e.col}) => ${e.value}`\n                    );\n                } else {\n                    this.errors.push(e);\n                    if (this.errors.length > 100) {\n                        this.errors.push(\"Parse Error limit exceeded\");\n                        return statements;\n                    }\n                }\n                this.synchronize();\n            }\n        }\n        return statements;\n    }\n\n    private match(...types: TokenType[]): boolean {\n        for (const type of types) {\n            if (this.check(type)) {\n                this.advance();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private advance(): Token {\n        if (!this.eof()) {\n            this.current++;\n        }\n        return this.previous();\n    }\n\n    private peek(): Token {\n        return this.tokens[this.current];\n    }\n\n    private previous(): Token {\n        return this.tokens[this.current - 1];\n    }\n\n    private peekNext(): Token {\n        if (!this.eof()) {\n            return this.tokens[this.current + 1];\n        }\n        return this.peek();\n    }\n\n    private check(type: TokenType): boolean {\n        return this.peek().type === type;\n    }\n\n    private eof(): boolean {\n        return this.check(TokenType.Eof);\n    }\n\n    private consume(type: TokenType, message: string): Token {\n        if (this.check(type)) {\n            return this.advance();\n        }\n\n        return this.error(\n            this.previous(),\n            message + `, unexpected token \"${this.peek().lexeme}\"`\n        );\n    }\n\n    private extraSemicolon(): boolean {\n        const match = this.match(TokenType.Semicolon);\n        if (this.check(TokenType.Semicolon)) {\n            while (this.check(TokenType.Semicolon)) {\n                this.consume(TokenType.Semicolon, \"\");\n            }\n        }\n        return match;\n    }\n\n    private error(token: Token, message: string): any {\n        throw new $Error(message, token.line, token.col);\n    }\n\n    private warning(message: string): void {\n        if (this.errorLevel === 1) {\n            const token = this.previous();\n            conzole.warn(\n                `[line (${token.line}) parse warning at \"${token.lexeme}\"] => ${message}`\n            );\n        }\n    }\n\n    private synchronize(): void {\n        do {\n            switch (this.peek().type) {\n                case TokenType.Class:\n                case TokenType.Function:\n                case TokenType.Var:\n                case TokenType.For:\n                case TokenType.If:\n                case TokenType.While:\n                case TokenType.Do:\n                case TokenType.Print:\n                case TokenType.Return:\n                    this.advance();\n                    return;\n            }\n            if (\n                this.check(TokenType.Semicolon) ||\n                this.check(TokenType.RightBrace)\n            ) {\n                this.advance();\n                return;\n            }\n            this.advance();\n        } while (!this.eof());\n    }\n\n    private declaration(): Stmt.Stmt {\n        if (this.match(TokenType.Class)) {\n            return this.classDeclaration();\n        }\n        if (this.match(TokenType.Function)) {\n            return this.funcDeclaration(\"function\");\n        }\n        if (this.match(TokenType.Var)) {\n            return this.varDeclaration();\n        }\n        return this.statement();\n    }\n\n    private classDeclaration(): Stmt.Class {\n        const name: Token = this.consume(\n            TokenType.Identifier,\n            `Expected a class name`\n        );\n        let parent: Token = null;\n        if (this.match(TokenType.Extends)) {\n            parent = this.consume(\n                TokenType.Identifier,\n                `Expected a parent name`\n            );\n        }\n        this.consume(\n            TokenType.LeftBrace,\n            `Expected open brace \"{\" after class name`\n        );\n        const methods: Stmt.Func[] = [];\n\n        while (!this.check(TokenType.RightBrace) && !this.eof()) {\n            if (this.check(TokenType.Function)) {\n                this.consume(TokenType.Function, \"\");\n            }\n            methods.push(this.funcDeclaration(\"method\"));\n        }\n\n        this.consume(\n            TokenType.RightBrace,\n            `Expected \"}\" after class \"${name.literal}\" methods`\n        );\n        if (this.extraSemicolon()) {\n            this.warning(\n                `Unnecessary semicolon after class ${name.lexeme} declaration`\n            );\n        }\n        return new Stmt.Class(name, parent, methods, name.line);\n    }\n\n    private funcDeclaration(kind: string): Stmt.Func {\n        const name: Token = this.consume(\n            TokenType.Identifier,\n            `Expected a ${kind} name`\n        );\n        return this.funcParamsBody(name, kind);\n    }\n\n    private funcParams(kind: string): Token[] {\n        const params: Token[] = [];\n        if (!this.check(TokenType.RightParen)) {\n            do {\n                if (params.length >= 255) {\n                    this.error(this.peek(), `Parameter count exceeds 255`);\n                }\n                params.push(\n                    this.consume(\n                        TokenType.Identifier,\n                        `Expected a parameter name`\n                    )\n                );\n            } while (this.match(TokenType.Comma));\n        }\n        this.consume(\n            TokenType.RightParen,\n            `Expected close parenthesis \")\" after ${kind} parameters`\n        );\n        return params;\n    }\n\n    private funcParamsBody(name: Token, kind: string): Stmt.Func {\n        this.consume(\n            TokenType.LeftParen,\n            `Expected open parenthesis \"(\" after ${kind}`\n        );\n        const params: Token[] = this.funcParams(kind);\n\n        if (this.match(TokenType.LeftBrace)) {\n            const body: Stmt.Stmt[] = this.block();\n            if (name.type !== TokenType.Lambda && this.extraSemicolon()) {\n                this.warning(\n                    `Unnecessary semicolon after function ${name.lexeme} declaration`\n                );\n            }\n            return new Stmt.Func(name, params, body, name.line);\n        }\n\n        if (this.match(TokenType.Arrow)) {\n            const body: Stmt.Stmt[] = [];\n            let arrow: Expr.Expr;\n            const keyword: Token = this.previous();\n            if (!this.check(TokenType.Semicolon)) {\n                arrow = this.expression();\n            }\n            this.match(TokenType.Semicolon);\n            body.push(new Stmt.Return(keyword, arrow, keyword.line));\n            return new Stmt.Func(name, params, body, name.line);\n        }\n        this.consume(TokenType.LeftBrace, `Expect \"{\" before ${kind} body`);\n    }\n\n    private varDeclaration(): Stmt.Stmt {\n        const name: Token = this.consume(\n            TokenType.Identifier,\n            `Expected a variable name after \"var\" keyword`\n        );\n        let initializer: Expr.Expr = null;\n        if (this.match(TokenType.Equal)) {\n            initializer = this.expression();\n        }\n        this.consume(\n            TokenType.Semicolon,\n            `Expected semicolon \";\" after a variable declaration`\n        );\n\n        return new Stmt.Var(name, null, initializer, name.line);\n    }\n\n    private statement() {\n        if (this.match(TokenType.If)) {\n            return this.ifStatement();\n        }\n        if (this.match(TokenType.Print)) {\n            return this.printStatement();\n        }\n        if (this.match(TokenType.Do)) {\n            return this.doWhileStatement();\n        }\n        if (this.match(TokenType.While)) {\n            return this.whileStatement();\n        }\n        if (this.match(TokenType.For)) {\n            return this.forStatement();\n        }\n        if (this.match(TokenType.Foreach)) {\n            return this.foreachStatement();\n        }\n        if (this.match(TokenType.LeftBrace)) {\n            return new Stmt.Block(this.block(), this.previous().line);\n        }\n        if (this.match(TokenType.Return)) {\n            return this.returnStatement();\n        }\n        if (this.match(TokenType.Break)) {\n            return this.breakStatement();\n        }\n        if (this.match(TokenType.Continue)) {\n            return this.continueStatement();\n        }\n        return this.expressionStatement();\n    }\n\n    private ifStatement(): Stmt.Stmt {\n        const keyword = this.previous();\n        this.consume(\n            TokenType.LeftParen,\n            `Expected open parenthesis \"(\" after an \"if\" keyword`\n        );\n        const condition: Expr.Expr = this.expression();\n        this.consume(\n            TokenType.RightParen,\n            `Expected close parenthesis \")\" after \"if\" statement condition`\n        );\n        const thenStmt: Stmt.Stmt = this.statement();\n        let elseStmt: Stmt.Stmt = null;\n        if (this.match(TokenType.Else)) {\n            elseStmt = this.statement();\n        }\n        return new Stmt.If(condition, thenStmt, elseStmt, keyword.line);\n    }\n\n    private whileStatement(): Stmt.Stmt {\n        const keyword = this.previous();\n        this.consume(\n            TokenType.LeftParen,\n            `Expected open parenthesis \"(\" after a \"while\" statement`\n        );\n        const condition: Expr.Expr = this.expression();\n        this.consume(\n            TokenType.RightParen,\n            `Expected close parenthesis \")\" after \"while\" condition`\n        );\n        const loop: Stmt.Stmt = this.statement();\n        return new Stmt.While(condition, loop, keyword.line);\n    }\n\n    private forStatement(): Stmt.Stmt {\n        const keyword = this.previous();\n        this.consume(\n            TokenType.LeftParen,\n            `Expected open parenthesis \"(\" after a \"for\" statement`\n        );\n\n        let initializer: Stmt.Stmt;\n        if (this.match(TokenType.Semicolon)) {\n            initializer = null;\n        } else if (this.match(TokenType.Var)) {\n            initializer = this.varDeclaration();\n        } else {\n            initializer = this.expressionStatement();\n        }\n        let condition: Expr.Expr;\n        if (!this.check(TokenType.Semicolon)) {\n            condition = this.expression();\n        }\n        this.consume(\n            TokenType.Semicolon,\n            `Expected semicolon \";\" after a \"for\" statement loop condition`\n        );\n        let increment: Expr.Expr;\n        if (!this.check(TokenType.RightParen)) {\n            increment = this.expression();\n        }\n        this.consume(\n            TokenType.RightParen,\n            `Expected semicolon \";\" after a \"for\" stement increment expression`\n        );\n        let body: Stmt.Stmt = this.statement();\n        if (increment !== null) {\n            body = new Stmt.Block(\n                [body, new Stmt.Expression(increment, keyword.line)],\n                keyword.line\n            );\n        }\n        if (condition === null) {\n            condition = new Expr.Literal(new $Boolean(true), keyword.line);\n        }\n        body = new Stmt.While(condition, body, keyword.line);\n        if (initializer !== null) {\n            body = new Stmt.Block([initializer, body], keyword.line);\n        }\n        return body;\n    }\n\n    private foreachStatement(): Stmt.Stmt {\n        const keyword = this.previous();\n        this.consume(\n            TokenType.LeftParen,\n            `Expected open parenthesis \"(\" after a \"foreach\" statement`\n        );\n        const name = this.consume(\n            TokenType.Identifier,\n            `Expected an identifier inside \"foreach\" statement`\n        );\n        let key: Token = null;\n        if (this.match(TokenType.With)) {\n            key = this.consume(\n                TokenType.Identifier,\n                `Expected a \"key\" identifier after \"with\" keyword in foreach statement`\n            );\n        }\n        this.consume(\n            TokenType.In,\n            `Expected \"in\" keyword inside foreach statement`\n        );\n        const iterable = this.expression();\n        this.consume(\n            TokenType.RightParen,\n            `Expected close parenthesis \")\" after a \"foreach\" initialization`\n        );\n\n        const loop: Stmt.Stmt = this.statement();\n        let none: Stmt.Stmt | null = null;\n        if (this.match(TokenType.None)) {\n            none = this.statement();\n        }\n        return new Stmt.Foreach(name, key, iterable, loop, none, keyword.line);\n    }\n\n    private doWhileStatement(): Stmt.Stmt {\n        const keyword = this.previous();\n        const loop: Stmt.Stmt = this.statement();\n        this.consume(\n            TokenType.While,\n            `Expected a \"while\" condition after \"do\" statement`\n        );\n        this.consume(\n            TokenType.LeftParen,\n            `Expected open parenthesis \"(\" after a \"while\" keyword`\n        );\n        const condition: Expr.Expr = this.expression();\n        this.consume(\n            TokenType.RightParen,\n            `Expected close parenthesis \")\" after \"while\" condition`\n        );\n        this.consume(\n            TokenType.Semicolon,\n            `Expected semicolon \";\" after a do while condition`\n        );\n        return new Stmt.DoWhile(loop, condition, keyword.line);\n    }\n\n    private printStatement(): Stmt.Stmt {\n        const keyword = this.previous();\n        const value: Expr.Expr = this.expression();\n        this.consume(\n            TokenType.Semicolon,\n            `Expected semicolon \";\" after expression`\n        );\n        return new Stmt.Print(value, keyword.line);\n    }\n\n    private returnStatement(): Stmt.Stmt {\n        const keyword: Token = this.previous();\n        let value = null;\n\n        if (!this.check(TokenType.Semicolon)) {\n            value = this.expression();\n        }\n\n        this.consume(\n            TokenType.Semicolon,\n            `Exected semicolon \";\" after return statement`\n        );\n        return new Stmt.Return(keyword, value, keyword.line);\n    }\n\n    private breakStatement(): Stmt.Stmt {\n        const keyword: Token = this.previous();\n        this.consume(\n            TokenType.Semicolon,\n            `Exected semicolon \";\" after break statement`\n        );\n        return new Stmt.Break(keyword, keyword.line);\n    }\n\n    private continueStatement(): Stmt.Stmt {\n        const keyword: Token = this.previous();\n        this.consume(\n            TokenType.Semicolon,\n            `Exected semicolon \";\" after continue statement`\n        );\n        return new Stmt.Continue(keyword, keyword.line);\n    }\n\n    private block(): Stmt.Stmt[] {\n        const statements: Stmt.Stmt[] = [];\n        while (!this.check(TokenType.RightBrace) && !this.eof()) {\n            statements.push(this.declaration());\n        }\n        this.consume(\n            TokenType.RightBrace,\n            `Expected close brace \"}\" after block statement`\n        );\n        return statements;\n    }\n\n    private expressionStatement(): Stmt.Stmt {\n        const expression: Expr.Expr = this.expression();\n        this.consume(\n            TokenType.Semicolon,\n            `Expected semicolon \";\" after ${expression} expression`\n        );\n        if (this.match(TokenType.Semicolon)) {\n            const token = this.previous();\n            this.warning(\n                `[line (${token.line}) parse warning at \"${token.lexeme}\"] => unnecessary semicolon or empty statement`\n            );\n            // consume all semicolons\n            // tslint:disable-next-line\n            while (this.match(TokenType.Semicolon)) {}\n        }\n        return new Stmt.Expression(expression, expression.line);\n    }\n\n    private expression(): Expr.Expr {\n        return this.assignment();\n    }\n\n    private assignment(): Expr.Expr {\n        const expr: Expr.Expr = this.ternary();\n        if (\n            this.match(\n                TokenType.Equal,\n                TokenType.PlusEqual,\n                TokenType.MinusEqual,\n                TokenType.StarEqual,\n                TokenType.SlashEqual\n            )\n        ) {\n            const operator: Token = this.previous();\n            let value: Expr.Expr = this.assignment();\n            if (expr instanceof Expr.Variable) {\n                const name: Token = expr.name;\n                if (operator.type !== TokenType.Equal) {\n                    value = new Expr.Binary(\n                        new Expr.Variable(name, name.line),\n                        operator,\n                        value,\n                        operator.line\n                    );\n                }\n                return new Expr.Assign(name, value, name.line);\n            } else if (expr instanceof Expr.Get) {\n                if (operator.type !== TokenType.Equal) {\n                    value = new Expr.Binary(\n                        new Expr.Get(\n                            expr.entity,\n                            expr.key,\n                            expr.type,\n                            expr.line\n                        ),\n                        operator,\n                        value,\n                        operator.line\n                    );\n                }\n                return new Expr.Set(expr.entity, expr.key, value, expr.line);\n            }\n            this.error(\n                operator,\n                `Invalid l-value, is not an assigning target.`\n            );\n        }\n        return expr;\n    }\n\n    private ternary(): Expr.Expr {\n        const expr = this.nullCoalescing();\n        if (this.match(TokenType.Question)) {\n            const thenExpr: Expr.Expr = this.ternary();\n            this.consume(\n                TokenType.Colon,\n                `Expected \":\" after ternary ? expression`\n            );\n            const elseExpr: Expr.Expr = this.ternary();\n            return new Expr.Ternary(expr, thenExpr, elseExpr, expr.line);\n        }\n        return expr;\n    }\n\n    private nullCoalescing(): Expr.Expr {\n        const expr = this.logicalOr();\n        if (this.match(TokenType.QuestionQuestion)) {\n            const rightExpr: Expr.Expr = this.nullCoalescing();\n            return new Expr.NullCoalescing(expr, rightExpr, expr.line);\n        }\n        return expr;\n    }\n\n    private logicalOr(): Expr.Expr {\n        let expr = this.logicalAnd();\n        while (this.match(TokenType.Or)) {\n            const operator: Token = this.previous();\n            const right: Expr.Expr = this.logicalAnd();\n            expr = new Expr.Logical(expr, operator, right, operator.line);\n        }\n        return expr;\n    }\n\n    private logicalAnd(): Expr.Expr {\n        let expr = this.equality();\n        while (this.match(TokenType.And)) {\n            const operator: Token = this.previous();\n            const right: Expr.Expr = this.equality();\n            expr = new Expr.Logical(expr, operator, right, operator.line);\n        }\n        return expr;\n    }\n\n    private equality(): Expr.Expr {\n        let expr = this.instanceof();\n        while (\n            this.match(\n                TokenType.BangEqual,\n                TokenType.EqualEqual,\n                TokenType.LessEqualGreater\n            )\n        ) {\n            const operator: Token = this.previous();\n            const right: Expr.Expr = this.instanceof();\n            expr = new Expr.Binary(expr, operator, right, operator.line);\n        }\n        return expr;\n    }\n\n    private instanceof(): Expr.Expr {\n        let expr = this.in();\n        while (this.match(TokenType.Is, TokenType.Instanceof)) {\n            const operator = this.previous();\n            if (\n                this.match(\n                    TokenType.Identifier,\n                    TokenType.Class,\n                    TokenType.Function,\n                    TokenType.Null\n                )\n            ) {\n                const right = this.previous();\n                if (operator.type === TokenType.Instanceof) {\n                    expr = new Expr.InstanceOf(expr, right, operator.line);\n                } else {\n                    expr = new Expr.Is(expr, right, operator.line);\n                }\n            } else {\n                this.error(\n                    this.previous(),\n                    `Expected a Type or ClassName identifier after \"is\" operator`\n                );\n            }\n        }\n        return expr;\n    }\n\n    private in(): Expr.Expr {\n        let expr = this.comparison();\n        while (this.match(TokenType.In)) {\n            const operator = this.previous();\n            const entity = this.expression();\n            expr = new Expr.In(expr, entity, operator.line);\n        }\n        return expr;\n    }\n\n    private comparison(): Expr.Expr {\n        let expr: Expr.Expr = this.addition();\n        while (\n            this.match(\n                TokenType.Greater,\n                TokenType.GreaterEqual,\n                TokenType.Less,\n                TokenType.LessEqual\n            )\n        ) {\n            const operator: Token = this.previous();\n            const right: Expr.Expr = this.addition();\n            expr = new Expr.Binary(expr, operator, right, operator.line);\n        }\n        return expr;\n    }\n\n    private addition(): Expr.Expr {\n        let expr: Expr.Expr = this.modulus();\n        while (this.match(TokenType.Minus, TokenType.Plus)) {\n            const operator: Token = this.previous();\n            const right: Expr.Expr = this.modulus();\n            expr = new Expr.Binary(expr, operator, right, operator.line);\n        }\n        return expr;\n    }\n\n    private modulus(): Expr.Expr {\n        let expr: Expr.Expr = this.multiplication();\n        while (this.match(TokenType.Percent)) {\n            const operator: Token = this.previous();\n            const right: Expr.Expr = this.multiplication();\n            expr = new Expr.Binary(expr, operator, right, operator.line);\n        }\n        return expr;\n    }\n\n    private multiplication(): Expr.Expr {\n        let expr: Expr.Expr = this.typeof();\n        while (this.match(TokenType.Slash, TokenType.Star)) {\n            const operator: Token = this.previous();\n            const right: Expr.Expr = this.typeof();\n            expr = new Expr.Binary(expr, operator, right, operator.line);\n        }\n        return expr;\n    }\n\n    private typeof(): Expr.Expr {\n        if (this.match(TokenType.Typeof)) {\n            const operator: Token = this.previous();\n            const value: Expr.Expr = this.typeof();\n            return new Expr.Typeof(value, operator.line);\n        }\n        return this.delete();\n    }\n\n    private delete(): Expr.Expr {\n        if (this.match(TokenType.Delete)) {\n            const operator: Token = this.previous();\n            const value: Expr.Expr = this.delete();\n            return new Expr.Delete(value, operator.line);\n        }\n        return this.range();\n    }\n\n    private range(): Expr.Expr {\n        let expr: Expr.Expr = this.unary();\n        if (this.match(TokenType.DotDot)) {\n            const end: Expr.Expr = this.unary();\n            expr = new Expr.Range(expr, end, null, expr.line);\n        }\n        return expr;\n    }\n\n    private unary(): Expr.Expr {\n        if (\n            this.match(\n                TokenType.Minus,\n                TokenType.Bang,\n                TokenType.Dollar,\n                TokenType.PlusPlus,\n                TokenType.MinusMinus\n            )\n        ) {\n            const operator: Token = this.previous();\n            const right: Expr.Expr = this.unary();\n            return new Expr.Unary(operator, right, operator.line);\n        }\n        return this.newKeyword();\n    }\n\n    private newKeyword(): Expr.Expr {\n        if (this.match(TokenType.New)) {\n            const keyword = this.previous();\n            const construct: Expr.Expr = this.call();\n            return new Expr.New(construct, keyword.line);\n        }\n        return this.call();\n    }\n\n    private call(): Expr.Expr {\n        let expr: Expr.Expr = this.primary();\n        let consumed = true;\n        do {\n            consumed = false;\n            if (this.match(TokenType.LeftParen)) {\n                consumed = true;\n                do {\n                    const args: Expr.Expr[] = [];\n                    if (!this.check(TokenType.RightParen)) {\n                        do {\n                            args.push(this.expression());\n                        } while (this.match(TokenType.Comma));\n                    }\n                    const paren: Token = this.consume(\n                        TokenType.RightParen,\n                        `Expected \")\" after arguments`\n                    );\n                    expr = new Expr.Call(expr, paren, args, null, paren.line);\n                } while (this.match(TokenType.LeftParen));\n            }\n            if (this.match(TokenType.Dot, TokenType.QuestionDot)) {\n                consumed = true;\n                expr = this.dotGet(expr, this.previous());\n            }\n            if (this.match(TokenType.LeftBracket)) {\n                consumed = true;\n                expr = this.bracketGet(expr, this.previous());\n            }\n        } while (consumed);\n        return expr;\n    }\n\n    private dotGet(expr: Expr.Expr, operator: Token): Expr.Expr {\n        const name: Token = this.consume(\n            TokenType.Identifier,\n            `Expect property name after '.'`\n        );\n        const key: Expr.Key = new Expr.Key(name, name.line);\n        return new Expr.Get(expr, key, operator.type, name.line);\n    }\n\n    private bracketGet(expr: Expr.Expr, operator: Token): Expr.Expr {\n        let key: Expr.Expr = null;\n        let end: Expr.Expr = null;\n        let step: Expr.Expr = new Expr.Literal(new $Number(1), operator.line);\n        let isRange = false;\n\n        if (!this.check(TokenType.Colon)) {\n            key = this.expression();\n        }\n        if (this.match(TokenType.Colon) && !this.check(TokenType.Colon)) {\n            isRange = true;\n            end = this.expression();\n        }\n        if (\n            this.match(TokenType.Colon) &&\n            !this.check(TokenType.RightBracket)\n        ) {\n            isRange = true;\n            step = this.expression();\n        }\n        this.consume(TokenType.RightBracket, `Expected \"]\" after an index`);\n        if (isRange) {\n            const range = new Expr.Range(key, end, step, operator.line);\n            return new Expr.Get(expr, range, operator.type, operator.line);\n        }\n        return new Expr.Get(expr, key, operator.type, operator.line);\n    }\n\n    private primary(): Expr.Expr {\n        if (this.match(TokenType.False)) {\n            return new Expr.Literal(new $Boolean(false), this.previous().line);\n        }\n        if (this.match(TokenType.True)) {\n            return new Expr.Literal(new $Boolean(true), this.previous().line);\n        }\n        if (this.match(TokenType.Null)) {\n            return new Expr.Literal(new $Null(), this.previous().line);\n        }\n        if (this.match(TokenType.Number)) {\n            return new Expr.Literal(\n                new $Number(this.previous().literal),\n                this.previous().line\n            );\n        }\n        if (this.match(TokenType.String)) {\n            return new Expr.Ztring(\n                this.previous().literal,\n                this.previous().line\n            );\n        }\n        if (this.match(TokenType.Template)) {\n            return new Expr.Template(\n                this.previous().literal,\n                this.previous().line\n            );\n        }\n        if (this.match(TokenType.Regex)) {\n            return new Expr.RegEx(\n                this.previous().literal,\n                this.previous().line\n            );\n        }\n        if (this.match(TokenType.Base)) {\n            const paren = this.previous();\n            paren.lexeme = \"this\";\n            return new Expr.Base(paren, paren.line);\n        }\n        if (this.match(TokenType.Identifier)) {\n            const identifier = this.previous();\n            if (this.match(TokenType.PlusPlus)) {\n                return new Expr.Postfix(identifier, 1, identifier.line);\n            }\n            if (this.match(TokenType.MinusMinus)) {\n                return new Expr.Postfix(identifier, -1, identifier.line);\n            }\n            return new Expr.Variable(identifier, identifier.line);\n        }\n        if (this.match(TokenType.LeftParen)) {\n            const expr: Expr.Expr = this.expression();\n            this.consume(TokenType.RightParen, `Expected \")\" after expression`);\n            return new Expr.Grouping(expr, expr.line);\n        }\n        if (this.match(TokenType.LeftBrace)) {\n            return this.dictionary();\n        }\n        if (this.match(TokenType.Function)) {\n            const token: Token = new Token(\n                TokenType.Lambda,\n                \"@\",\n                \"@\",\n                this.previous().line,\n                this.previous().col\n            );\n            const lambda: Stmt.Func = this.funcParamsBody(token, \"lambda\");\n            return new Expr.Lambda(lambda, token.line);\n        }\n        if (this.match(TokenType.LeftBracket)) {\n            return this.list();\n        }\n        if (this.match(TokenType.Void)) {\n            const expr: Expr.Expr = this.expression();\n            return new Expr.Void(expr, this.previous().line);\n        }\n        if (this.match(TokenType.DotDotDot)) {\n            const expr: Expr.Expr = this.range();\n            return new Expr.Spread(expr, this.previous().line);\n        }\n        if (this.match(TokenType.Hash)) {\n            return new Expr.Char(this.call(), this.previous().line);\n        }\n\n        throw this.error(\n            this.peek(),\n            `Expected expression, unexpected token \"${this.peek().lexeme}\"`\n        );\n        // unreacheable code\n        return new Expr.Literal(null, 0);\n    }\n\n    public dictionary(): Expr.Expr {\n        const leftBrace = this.previous();\n        if (this.match(TokenType.RightBrace)) {\n            return new Expr.Dictionary([], this.previous().line);\n        }\n        const properties: Expr.Expr[] = [];\n        do {\n            if (\n                this.match(\n                    TokenType.String,\n                    TokenType.Identifier,\n                    TokenType.Number\n                )\n            ) {\n                const key: Token = this.previous();\n                if (this.match(TokenType.Colon)) {\n                    const value = this.expression();\n                    properties.push(\n                        new Expr.Set(\n                            null,\n                            new Expr.Key(key, key.line),\n                            value,\n                            key.line\n                        )\n                    );\n                } else {\n                    const value = new Expr.Variable(key, key.line);\n                    properties.push(\n                        new Expr.Set(\n                            null,\n                            new Expr.Key(key, key.line),\n                            value,\n                            key.line\n                        )\n                    );\n                }\n            } else if (this.match(TokenType.DotDotDot)) {\n                const value = this.expression();\n                properties.push(new Expr.Spread(value, value.line));\n            } else {\n                this.error(\n                    this.peek(),\n                    `String, Number or Identifier expected as a Key of Dictionary {, unexpected token ${\n                        this.peek().lexeme\n                    }`\n                );\n            }\n        } while (this.match(TokenType.Comma));\n        this.consume(TokenType.RightBrace, `Expected \"}\" after object literal`);\n\n        return new Expr.Dictionary(properties, leftBrace.line);\n    }\n\n    private list(): Expr.Expr {\n        const values: Expr.Expr[] = [];\n        const leftBracket = this.previous();\n\n        if (this.match(TokenType.RightBracket)) {\n            return new Expr.List([], this.previous().line);\n        }\n\n        if (this.peekNext().type === TokenType.Colon) {\n            let step: Expr.Expr = new Expr.Literal(\n                new $Number(1),\n                leftBracket.line\n            );\n            const start: Expr.Expr = this.expression();\n            this.consume(\n                TokenType.Colon,\n                `Expected \":\" color after start of range expression`\n            );\n            const end = this.expression();\n            this.consume(\n                TokenType.Colon,\n                `Expected \":\" color after end of range expression`\n            );\n            if (!this.check(TokenType.RightBracket)) {\n                step = this.expression();\n            }\n            values.push(new Expr.Range(start, end, step, start.line));\n        } else {\n            do {\n                values.push(this.expression());\n            } while (this.match(TokenType.Comma));\n        }\n\n        this.consume(\n            TokenType.RightBracket,\n            `Expected \"]\" after array declaration`\n        );\n        return new Expr.List(values, leftBracket.line);\n    }\n}\n","import { Token } from './token';\nimport { Console } from './console';\nimport { $Any } from './types/any';\nimport { $Null } from './types/null';\ndeclare var conzole: Console;\n\nexport class Scope {\n\n    private values: Map<string, any>;\n    private parent: Scope;\n\n    constructor(parent: Scope = null) {\n        this.values = new Map();\n        this.parent = parent;\n    }\n\n    private error(message: string): void {\n        throw new Error(`Runtime Error => ${message}`);\n    }\n\n    public set(name: string, value: $Any) {\n        this.values.set(name, value);\n    }\n\n    public define(name: string, value: $Any) {\n        if (this.values.has(name)) {\n            this.error(`Identifier \"${name}\" has already been defined`);\n        } else {\n            this.set(name, value);\n        }\n    }\n\n    public assign(name: string, value: $Any): void {\n        if (this.values.has(name)) {\n            this.set(name, value);\n        } else {\n            if (this.parent !== null) {\n                return this.parent.assign(name, value);\n            }\n            this.error(`Identifier \"${name}\" has not been defined`);\n        }\n    }\n\n    public get(key: string, token: Token = null): $Any {\n        if (this.values.has(key)) {\n            return this.values.get(key);\n        }\n        if (this.parent !== null ) {\n            return this.parent.get(key);\n        }\n\n        if (token) {\n            this.error(` at (${token.line}:${token.col}) => \"${token.lexeme}\" is not defined`);\n        } else {\n            this.error(`\"${key}\" is not defined`);\n        }\n        return new $Null();\n    }\n\n}\n","import * as Stmt from \"./statement\";\nimport { $Any } from \"./any\";\nimport { Console } from \"../console\";\nimport { DataType } from \"./type.enum\";\nimport { Interpreter } from \"../interpreter\";\nimport { Scope } from \"../scope\";\nimport { $Null } from \"./null\";\ndeclare var conzole: Console;\n\nexport type FunctionCall = (\n    thiz: $Any,\n    args: $Any[],\n    interpreter: Interpreter\n) => $Any;\n\nexport class $Callable extends $Any {\n    public value: FunctionCall;\n    public arity: number;\n    public name: string;\n\n    constructor(name: string, arity: number, value: FunctionCall) {\n        super(value, DataType.Function);\n        this.arity = arity;\n        this.name = name;\n    }\n\n    public call(thiz: any, args: any[], interpreter: Interpreter): $Any {\n        return this.value(thiz, args, interpreter);\n    }\n\n    public toString(): string {\n        return `<${this.name}  function>`;\n    }\n}\n\nexport class $Function extends $Callable {\n    public declaration: Stmt.Func;\n    public name: string;\n    private closure: Scope;\n\n    constructor(declaration: Stmt.Func, closure: Scope) {\n        super(declaration.name.lexeme, declaration.params.length, null);\n        this.declaration = declaration;\n        this.closure = closure;\n    }\n\n    public call(thiz: any, args: any[], interpreter: Interpreter): $Any {\n        const scope = new Scope(this.closure);\n        for (let i = 0; i < this.declaration.params.length; i++) {\n            scope.define(this.declaration.params[i].lexeme, args[i]);\n        }\n        scope.set(\"this\", thiz);\n        let restoreScope: Scope = null;\n        try {\n            restoreScope = interpreter.scope;\n            interpreter.executeBlock(this.declaration.body, scope);\n        } catch (e: any) {\n            if (e instanceof $Any && e.type === DataType.Return) {\n                if (restoreScope) {\n                    interpreter.scope = restoreScope;\n                }\n                return e.value;\n            } else {\n                throw e;\n            }\n        }\n        return new $Null();\n    }\n}\n","import { fromJavaScriptMethod } from '../runtime';\nimport { Interpreter } from '../interpreter';\nimport { $Any } from './any';\nimport { $Function, $Callable } from './function';\nimport { $Null } from './null';\nimport { $Number } from './number';\nimport { DataType } from './type.enum';\nimport { $Range } from './range';\n\nexport class $List extends $Any {\n    public value: $Any[];\n\n    constructor(value: $Any[]) {\n        super(value, DataType.List);\n    }\n\n    public get(key: $Any): $Any {\n        if (key.isNumber()) {\n            if (typeof this.value[key.value] !== 'undefined') {\n                return this.value[key.value];\n            } else {\n                return new $Null();\n            }\n        } else if (key.isRange()) {\n            return this.range(<$Range> key);\n        } else if ($List.runtime.has(key.value)) {\n            return $List.runtime.get(key.value);\n        } else {\n            return new $Null();\n        }\n\n    }\n\n    public set(key: $Any, value: $Any): $Any {\n        if (key.isNumber()) {\n            this.value[key.value] = value;\n        }\n        return value;\n    }\n\n    private range(range: $Range): $List {\n        const result: $Any[] = [];\n        range.iterate(this.value.length, (i) => {\n            result.push(this.value[i]);\n        });\n        return new $List(result);\n    }\n\n    public toString(): string {\n        return `[${this.value.join(',')}]`;\n    }\n\n    public static size(thiz: $Any, args: $Any[]): $Any {\n        return new $Number(args[0].value.length);\n    }\n\n    public static each(thiz: $Any, args: $Any[], interpreter: Interpreter): $Any {\n        for (let i = 0; i < thiz.value.length; ++i) {\n            (args[0] as $Function).call(thiz, [thiz.value[i], new $Number(i), thiz], interpreter);\n        }\n        return thiz;\n    }\n\n    public static sort(thiz: $Any, args: $Any[], interpreter: Interpreter): $Any {\n        const list = thiz.value as $Any[];\n        if (args.length) {\n            list.sort((a, b) =>\n                (args[0] as $Function).call(thiz, [a, b], interpreter).value\n            );\n        } else {\n            list.sort((a, b) =>\n               a.value - b.value\n            );\n        }\n        return thiz;\n    }\n\n    public static map(thiz: $Any, args: $Any[], interpreter: Interpreter): $Any {\n        for (let i = 0; i < thiz.value.length; ++i) {\n            thiz.value[i] = (args[0] as $Function).call(thiz, [new $Any(thiz.value[i]), new $Number(i), thiz], interpreter);\n        }\n        return thiz;\n    }\n\n    public static runtime =  new Map([\n        ['concat', fromJavaScriptMethod('concat', -1, DataType.List)],\n        ['each', new $Callable('each', 1, $List.each)],\n        ['sort', new $Callable('sort', -1, $List.sort)],\n        ['includes', fromJavaScriptMethod('includes', 1, DataType.Boolean)],\n        ['indexOf', fromJavaScriptMethod('indexOf', 1, DataType.Number)],\n        ['join', fromJavaScriptMethod('join', 1, DataType.String)],\n        ['lastIndexOf', fromJavaScriptMethod('lastIndexOf', 1, DataType.Number)],\n        ['map', new $Callable('map', 1, $List.map)],\n        ['pop', fromJavaScriptMethod('pop', 0, DataType.List)],\n        ['push', fromJavaScriptMethod('push', -1, DataType.List)],\n        ['shift', fromJavaScriptMethod('shift', 0, DataType.List)],\n        ['size', new $Callable('size', 0,  (thiz: $Any, args: $Any[]): $Any => new $Number(thiz.value.length))],\n        ['slice', fromJavaScriptMethod('slice', -1, DataType.List)],\n        ['splice', fromJavaScriptMethod('splice', -1, DataType.List)],\n        ['unshift', fromJavaScriptMethod('unshift', -1, DataType.List)]\n    ]);\n\n}\n","import { fromJavaScriptMethod } from '../runtime';\nimport { $Any } from './any';\nimport { $Callable, $Function } from './function';\nimport { $Null } from './null';\nimport { $Number } from './number';\nimport { DataType } from './type.enum';\nimport { Interpreter } from '../interpreter';\nimport { $Range } from './range';\nimport { $List } from './list';\n\nexport class $String extends $Any {\n    public value: string;\n\n    constructor(value: string) {\n        super(value, DataType.String);\n    }\n\n    public get(key: $Any): $Any {\n        if (key.isNumber()) {\n            return new $String(this.value[key.value]);\n        } else if (key.isRange()) {\n            return this.range(<$Range> key);\n        } else if ($String.runtime.has(key.value)) {\n            return $String.runtime.get(key.value);\n        }\n        return new $Null();\n\n    }\n\n    public set(key: $Any, value: any): $Any {\n        if (typeof key !== 'number') {\n            // this.properties.set(key, value);\n        }\n        return new $Null();\n    }\n\n    public toString(): string {\n        return `${this.value}`;\n    }\n\n    private range(range: $Range): $String {\n        let result = '';\n        range.iterate(this.value.length, (i: number) => {\n            result += this.value[i];\n        });\n        return new $String(result);\n    }\n\n    public static replace(thiz: $Any, args: $Any[], interpeter: Interpreter): $Any {\n        if (args[1].isFunction()) {\n            // return new $String(thiz.value.replace(args[0].value, args[1].value));\n            return thiz.value.replace(args[0].value, ((match: string) =>\n                ((args[1] as $Function).call(thiz, [new $String(match)], interpeter)).value\n            ));\n        }\n        return new $String(thiz.value.replace(args[0].value, args[1].value));\n    }\n\n    public static split(thiz: $Any, args: $Any[], interpeter: Interpreter): $Any {\n        const splits = thiz.value.split(args[0].value).map((str:string) => new $String(str));\n        return new $List(splits);\n    }\n\n    public static  runtime =  new Map([\n        ['toUpper',  fromJavaScriptMethod('toUpperCase', 0, DataType.String)],\n        ['toLower', fromJavaScriptMethod('toLowerCase', 0, DataType.String)],\n        ['size', new $Callable('size', 0,  (thiz: $Any, args: $Any[]): $Any => new $Number(thiz.value.length))],\n        ['split', new $Callable('split', 1, $String.split)],\n        ['concat', fromJavaScriptMethod('concat', 1, DataType.String)],\n        ['includes', fromJavaScriptMethod('includes', 1, DataType.Boolean)],\n        ['indexOf', fromJavaScriptMethod('indexOf', 1, DataType.Number)],\n        ['lastIndexOf', fromJavaScriptMethod('lastIndexOf', 1, DataType.Number)],\n        ['repeat', fromJavaScriptMethod('repeat', 1, DataType.String)],\n        ['replace', new $Callable('replace', -1, $String.replace)],\n        ['search', fromJavaScriptMethod('search', 1, DataType.Number)],\n        ['slice', fromJavaScriptMethod('slice', -1, DataType.String)],\n        ['substring', fromJavaScriptMethod('substring', -1, DataType.String)],\n        ['trim', fromJavaScriptMethod('trim', 0, DataType.String)],\n    ]);\n\n}\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\n\nexport class $Void extends $Any {\n\n    public value: boolean;\n\n    constructor(value: string) {\n        super(value, DataType.Void);\n    }\n\n}\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\n\nexport class $RegExp extends $Any {\n\n    public value: RegExp;\n\n    constructor(value: RegExp) {\n        super(value, DataType.RegExp);\n    }\n\n}\n","\nimport { fromJavaScriptMethod } from '../runtime';\nimport { Interpreter } from '../interpreter';\nimport { $Any } from './any';\nimport { $Function, $Callable } from './function';\nimport { $Null } from './null';\nimport { $Number } from './number';\nimport { $String } from './string';\nimport { DataType } from './type.enum';\nimport { $Iterator } from './iterator';\nimport { $Boolean } from './boolean';\n\nexport class $Dictionary extends $Any {\n    public value: Map<any, $Any>;\n\n    constructor(value: Map<any, $Any>) {\n        super(value, DataType.Dictionary);\n    }\n\n    public get(key: $Any): any {\n        if (this.value.has(key.value)) {\n            return this.value.get(key.value);\n        } else if ($Dictionary.runtime.has(key.value)) {\n            return $Dictionary.runtime.get(key.value);\n        } else {\n            return new $Null();\n        }\n    }\n\n    public set(key: $Any, value: $Any): $Any {\n        this.value.set(key.value, value);\n        return value;\n    }\n\n    public delete(key: $Any): $Any {\n        const result = this.value.delete(key.value);\n        return new $Boolean(result);\n    }\n\n    public toString(): string {\n        const result: any[] = [];\n        this.value.forEach((value, key) => {\n            result.push(`${key.toString()}: ${value}`);\n        });\n        return `{${result.join('; ')}}`;\n    }\n\n    public static each(thiz: $Any, args: $Any[], interpreter: Interpreter): $Any {\n        thiz.value.forEach((value: $Any, key: string) => {\n            (args[0] as $Function).call(thiz, [value, new $String(key), thiz], interpreter);\n        });\n        return thiz;\n    }\n\n    public static map(thiz: $Any, args: $Any[], interpreter: Interpreter): $Any {\n        thiz.value.forEach((value: $Any, key: string) => {\n            thiz.value.set('key', (args[0] as $Function).call(thiz, [value, new $String(key), thiz], interpreter));\n        });\n        return thiz;\n    }\n\n    public static indexOf(thiz: $Any, args: $Any[], interpreter: Interpreter): $Any {\n        let index: string = null;\n        thiz.value.forEach((value: $Any, key: string) => {\n            if (value.type === args[0].type && value.value === args[0].value) {\n                index = key;\n            }\n        });\n        if (index !== null) {\n            return new $String(index);\n        }\n        return new $Null();\n    }\n\n    public static runtime =  new Map([\n        ['clear', fromJavaScriptMethod('clear', 0, DataType.Null)],\n        ['delete', fromJavaScriptMethod('delete', 1, DataType.Boolean)],\n        ['each', new $Callable('each', 1, $Dictionary.each)],\n        ['has', fromJavaScriptMethod('has', 1, DataType.Boolean)],\n        ['indexOf', new $Callable('indexOf', 1, $Dictionary.indexOf)],\n        ['map', new $Callable('map', 1, $Dictionary.map)],\n        ['merge', new $Callable('merge', 1,  (thiz: $Any, args: $Any[]): $Any => new $Dictionary(new Map([...(thiz.value), ...(args[0].value)])))],\n        ['size', new $Callable('size', 0,  (thiz: $Any, args: $Any[]): $Any => new $Number(thiz.value.size))]\n    ]);\n\n}\n","import { DataType } from \"./type.enum\";\nimport { $Any } from \"./any\";\nimport { Interpreter } from \"../interpreter\";\nimport { $Dictionary } from \"./dictionary\";\nimport { $Null } from \"./null\";\nimport { $Callable } from \"./function\";\nimport { $List } from \"./list\";\nimport { $Boolean } from \"./boolean\";\nimport { $Number } from \"./number\";\nimport { $String } from \"./string\";\nimport { $Range, RangeValue } from \"./range\";\n\nexport class IteratorValue {\n    public value: $Any;\n    public index: $Any;\n    public done: $Any;\n    public inner: any;\n\n    constructor(value: $Any, index: $Any, done: $Any, inner: any) {\n        this.value = value;\n        this.index = index;\n        this.done = done;\n        this.inner = inner;\n    }\n}\n\nexport class $Iterator extends $Any {\n    public value: $Any;\n    public iter: IteratorValue;\n\n    constructor(value: $Any) {\n        super(value, DataType.RegExp);\n        this.iter = new IteratorValue(\n            new $Null(),\n            new $Null(),\n            new $Boolean(false),\n            null\n        );\n    }\n\n    public get(key: $Any): $Any {\n        if (key.value === \"key\" || key.value === \"index\") {\n            return this.iter.index;\n        }\n        if (key.value === \"done\") {\n            return this.iter.done;\n        }\n        if (key.value === \"value\") {\n            return this.iter.value;\n        }\n        if ($Iterator.runtime.has(key.value)) {\n            return $Iterator.runtime.get(key.value);\n        }\n        return new $Null();\n    }\n\n    public complete(): void {\n        this.iter.done = new $Boolean(true);\n        this.iter.value = new $Null();\n        this.iter.index = new $Null();\n    }\n\n    public set(key: $Any, value: $Any): $Any {\n        if (typeof this.iter[key.value as never] !== \"undefined\") {\n            (this.iter[key.value as never] as $Any) = value;\n        }\n        return value;\n    }\n\n    public toString(): string {\n        return `<${DataType[this.value.type]} iterator>`;\n    }\n\n    public static next(\n        thiz: $Any,\n        args: $Any[],\n        interpreter: Interpreter\n    ): $Any {\n        const it = thiz as $Iterator;\n\n        // already iterated, return completed iterator\n        if (it.iter.done.value) {\n            return it;\n        }\n\n        if (it.value.isList()) {\n            $Iterator.listNext(thiz);\n            return it;\n        }\n\n        if (it.value.isDictionary()) {\n            $Iterator.dictionaryNext(thiz);\n            return it;\n        }\n\n        if (it.value.isString()) {\n            $Iterator.stringNext(thiz);\n            return it;\n        }\n\n        if (it.value.isNumber()) {\n            $Iterator.numberNext(thiz);\n            return it;\n        }\n\n        if (it.value.isRange()) {\n            $Iterator.rangeNext(thiz);\n            return it;\n        }\n\n        if (it.value.isObject()) {\n            (thiz.value.get(interpreter.strings.next) as $Callable).call(\n                thiz.value,\n                [thiz as $Iterator],\n                interpreter\n            );\n            return it;\n        }\n\n        // default\n        interpreter.error(\n            `${DataType[it.value.type].toLowerCase()} with value ${\n                it.value\n            } is not an iterable`\n        );\n        it.complete();\n        return it;\n    }\n\n    public static listNext(thiz: $Any) {\n        const it = thiz as $Iterator;\n        const list = it.value as $List;\n        const index = it.iter.index;\n\n        // list is empty, no iteration required\n        if (!list.value.length) {\n            it.complete();\n            return it;\n        }\n\n        // first value\n        if (it.iter.inner === null) {\n            it.iter.inner = true;\n            it.iter.index = new $Number(0);\n            it.iter.value = list.value[0];\n            return it;\n        }\n\n        // no more values to iterate\n        if (index.value >= list.value.length - 1) {\n            it.complete();\n            return it;\n        }\n\n        // normal iteration\n        const newIndex = index.value + 1;\n        it.iter.index = new $Number(newIndex);\n        it.iter.value = list.value[newIndex];\n        return it;\n    }\n\n    public static stringNext(thiz: $Any) {\n        const it = thiz as $Iterator;\n        const str = it.value as $String;\n        const index = it.iter.index;\n\n        // string is empty\n        if (!str.value.length) {\n            it.complete();\n            return it;\n        }\n\n        // first value\n        if (it.iter.inner === null) {\n            it.iter.inner = true;\n            it.iter.index = new $Number(0);\n            it.iter.value = new $String(str.value.charAt(0));\n            return it;\n        }\n\n        // no more values to iterate\n        if (index.value >= str.value.length - 1) {\n            it.complete();\n            return it;\n        }\n\n        // normal iteration\n        const newIndex = index.value + 1;\n        it.iter.index = new $Number(newIndex);\n        it.iter.value = new $String(str.value.charAt(newIndex));\n        return it;\n    }\n\n    public static numberNext(thiz: $Any) {\n        const it = thiz as $Iterator;\n        const number = it.value as $Number;\n        const index = it.iter.index;\n\n        // number is 0 or negative\n        if (number.value <= 0) {\n            it.complete();\n            return it;\n        }\n\n        // first value\n        if (it.iter.inner === null) {\n            it.iter.inner = number.value - 1; //inner holds last value\n            it.iter.index = new $Number(0);\n            it.iter.value = it.iter.index;\n            return it;\n        }\n\n        // no more values to iterate\n        if (index.value >= it.iter.inner) {\n            it.complete();\n            return it;\n        }\n\n        // normal iteration\n        const newIndex = index.value + 1;\n        it.iter.index = new $Number(newIndex);\n        it.iter.value = it.iter.index;\n        return it;\n    }\n\n    public static rangeNext(thiz: $Any) {\n        const it = thiz as $Iterator;\n        const range = it.value as $Range;\n        const value: RangeValue = range.value;\n\n        // imposible range\n        if (\n            value.step === 0 ||\n            (value.start > value.end && value.step > 0) ||\n            (value.start < value.end && value.step < 0)\n        ) {\n            it.complete();\n            return it;\n        }\n\n        // first value\n        if (it.iter.inner === null) {\n            it.iter.inner = true;\n            it.iter.index = new $Number(0);\n            it.iter.value = new $Number(value.start);\n            return it;\n        }\n\n        if (value.step > 0) {\n            if (it.iter.value.value >= value.end) {\n                it.complete();\n                return it;\n            }\n        } else {\n            if (it.iter.value.value <= value.end) {\n                it.complete();\n                return it;\n            }\n        }\n\n        // normal iteration\n        const newIndex = it.iter.index.value + 1;\n        const newValue = it.iter.value.value + value.step;\n        it.iter.index = new $Number(newIndex);\n        it.iter.value = new $Number(newValue);\n        return it;\n    }\n\n    public static dictionaryNext(thiz: $Any): $Any {\n        const it = thiz as $Iterator;\n        const dict = it.value as $Dictionary;\n\n        // empty dictionary\n        if (!dict.value.size) {\n            it.complete();\n            return it;\n        }\n\n        // first value\n        if (it.iter.inner === null) {\n            it.iter.inner = dict.value.keys();\n        }\n\n        // normal iteration\n        const current = it.iter.inner.next();\n        it.iter.value = it.value.get(new $Any(current.value));\n        it.iter.index = new $String(current.value);\n\n        // no more values to iterate\n        if (current.done) {\n            it.complete();\n        }\n\n        return it;\n    }\n\n    public static first(\n        thiz: $Any,\n        args: $Any[],\n        interpreter: Interpreter\n    ): $Any {\n        if ((thiz as $Iterator).value.value.isList()) {\n            return new $Dictionary(\n                new Map([\n                    [\"key\", 0],\n                    [\"value\", thiz.value.value[0]],\n                ])\n            );\n        }\n        return new $Null();\n    }\n\n    public static runtime = new Map([\n        [\"first\", new $Callable(\"first\", 0, $Iterator.first)],\n        [\"next\", new $Callable(\"next\", 0, $Iterator.next)],\n    ]);\n}\n","import { DataType } from './types/type.enum';\nimport { $Null } from './types/null';\nimport { $Any } from './types/any';\nimport { $Callable, $Function } from './types/function';\nimport { $Boolean } from './types/boolean';\nimport { $List } from './types/list';\nimport { $Number } from './types/number';\nimport { $String } from './types/string';\nimport { $Void } from './types/void';\nimport { $RegExp } from './types/regex';\nimport { $Iterator } from './types/iterator';\n\nexport function fromJavaScriptMethod(jsName: string, arity: number, type: DataType): $Callable {\n    return new $Callable(jsName, arity, (thiz: $Any, args: $Any[]): $Any => {\n        const argValues = args.map((arg: $Any) => arg.value);\n        const result = thiz.value[jsName](...argValues);\n        switch (type) {\n            case DataType.Boolean:\n                return new $Boolean(result);\n            case DataType.String:\n                return new $String(result);\n            case DataType.Number:\n                return new $Number(result);\n            case DataType.List:\n                return new $List(result);\n            case DataType.Null:\n                return new $Null();\n            default:\n                return new $Any(result);\n        }\n    });\n}\n\nexport function fromJavaScriptFuncNumber(func: (...argz: any) => any, name: string, arity: number): $Callable {\n    return new $Callable(name, arity, (thiz: $Any, args: $Any[]): $Any => {\n        const argValues = args.map((arg: $Any) => arg.value);\n        const result = func(...argValues);\n        return new $Number(result);\n    });\n}\n\nexport function fromJavaScriptFuncVoid(func: (...argz: any) => any, name: string, arity: number): $Callable {\n    return new $Callable(name, arity, (thiz: $Any, args: $Any[]): $Any => {\n        const argValues = args.map((arg: $Any) => arg.value);\n        func(...argValues);\n        return new $Void('void');\n    });\n}\n\nexport const Runtime = {\n    Console:  new Map<string, $Any>([\n        ['log', fromJavaScriptFuncVoid(console.log, 'console.log', -1)],\n        ['warn', fromJavaScriptFuncVoid(console.warn, 'console.warn', -1)],\n        ['info', fromJavaScriptFuncVoid(console.info, 'console.info', -1)],\n        ['error', fromJavaScriptFuncVoid(console.error, 'console.error', -1)]\n    ]),\n    Math:  new Map<string, $Any>([\n        ['ceil', fromJavaScriptFuncNumber(Math.ceil, 'ceil', 1)],\n        ['cos', fromJavaScriptFuncNumber(Math.cos, 'cos', 1)],\n        ['floor', fromJavaScriptFuncNumber(Math.floor, 'floor', 1)],\n        ['log', fromJavaScriptFuncNumber(Math.log, 'log', 1)],\n        ['max', fromJavaScriptFuncNumber(Math.max, 'max', -1)],\n        ['min', fromJavaScriptFuncNumber(Math.min, 'min', -1)],\n        ['pi', new $Number(Math.PI)],\n        ['pow', fromJavaScriptFuncNumber(Math.pow, 'pow', 2)],\n        ['random', fromJavaScriptFuncNumber(Math.random, 'random', 0)],\n        ['round', fromJavaScriptFuncNumber(Math.round, 'round', 1)],\n        ['sin', fromJavaScriptFuncNumber(Math.sin, 'sin', 1)],\n        ['sqrt', fromJavaScriptFuncNumber(Math.sqrt, 'sqrt', 1)],\n        ['tan', fromJavaScriptFuncNumber(Math.tan, 'tan', 1)],\n        ['trunc', fromJavaScriptFuncNumber(Math.trunc, 'trunc', 1)]\n    ]),\n    Utils: new Map<string, $Any>([\n        ['re', new $Callable('regex', -1, (thiz: $Any, args: $Any[]): $Any => {\n            const values = args.map((arg) => arg.value);\n            if (values.length === 1) {\n                return new $RegExp(new RegExp(values[0]));\n            }\n            return new $RegExp(new RegExp(values[0], values[1]));\n        })],\n        ['iter', new $Callable('iter', 1, (thiz: $Any, args: $Any[]): $Any => {\n            return new $Iterator(args[0]);\n        })],\n        ['delay', new $Callable('delay', 2, (thiz: $Any, args: $Any[], interpreter): $Any => {\n            setTimeout(() => {\n                (args[0] as $Function).call(thiz, [], interpreter);\n            }, args[1].value);\n            return new $Null();\n        })],\n\n        ['fetch', new $Callable('fetch', 2, (thiz: $Any, args: $Any[], interpreter): $Any => {\n            fetch(args[0].value)\n                .then((response) => response.text())\n                .then((json) => {\n                    (args[1] as $Function).call(thiz, [new $String(json)], interpreter);\n                });\n            return new $Null();\n        })],\n    ])\n};\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\nimport { $Null } from './null';\nimport { $Boolean } from './boolean';\n\nexport class $Class extends $Any {\n    public value: Map<string, $Any>;\n    public name: string;\n    public parent: $Any;\n\n    constructor(name: string, value: Map<string, $Any>, parent: $Any) {\n        super(value, DataType.Class);\n        this.name = name;\n        this.parent = parent;\n    }\n\n    public get(key: $Any): $Any {\n        if (this.value.has(key.value)) {\n            return this.value.get(key.value);\n        }\n\n        if (this.parent.isClass()) {\n            return this.parent.get(key);\n        }\n\n        return new $Null();\n    }\n\n    public set(key: $Any, value: $Any): $Any {\n        this.value.set(key.value, value);\n        return value;\n    }\n\n    public delete(key: $Any): $Any {\n        const result = this.value.delete(key.value);\n        return new $Boolean(result);\n    }\n\n    public toString(): string {\n        return `<${this.name} class>`;\n    }\n\n}\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\nimport { $Null } from './null';\nimport { $Class } from './class';\nimport { $Boolean } from './boolean';\n\nexport class $Object extends $Any {\n    public value: Map<string, $Any>;\n    public conztructor: $Any;\n    public name: string;\n\n    constructor(value: Map<string, $Any>, conztructor: $Any) {\n        super(value, DataType.Object);\n        this.conztructor = conztructor;\n        this.name = (conztructor as $Class).name;\n    }\n\n    public get(key: $Any): $Any {\n        const method = this.conztructor.get(key);\n\n        if (method.isFunction()) {\n            return method;\n        }\n\n        if (this.value.has(key.value)) {\n            return this.value.get(key.value);\n        }\n\n        return new $Null();\n    }\n\n    public set(key: $Any, value: $Any): $Any {\n        this.value.set(key.value, value);\n        return value;\n    }\n\n    public delete(key: $Any): $Any {\n        const result = this.value.delete(key.value);\n        return new $Boolean(result);\n    }\n\n    public toString(): string {\n        return `<${this.name} object>`;\n    }\n}\n","import { DataType } from './type.enum';\nimport { $Any } from './any';\nimport { Console } from '../console';\ndeclare var conzole: Console;\n\nexport  class RangeValue {\n    public start: number;\n    public end: number;\n    public step: number;\n\n    constructor(start: number, end: number, step: number) {\n        this.start = start;\n        this.end = end;\n        this.step = step;\n    }\n\n    public normalize(length: number): void {\n        if (this.step === null) {\n            this.step = 1;\n        }\n        if (this.end === null) {\n            this.end = this.step > 0 ? length - 1 : 0;\n        }\n        if (this.start === null) {\n            this.start = this.step > 0 ? 0 : length - 1;\n        }\n    }\n}\n\nexport class $Range extends $Any {\n\n    constructor(value: RangeValue) {\n        super(value, DataType.Range);\n    }\n\n    public iterate(length: number, callback: (index: number) => void): void {\n        this.value.normalize(length);\n        if (this.value.step > 0) {\n            for (let i = this.value.start; i <= this.value.end; i += this.value.step) {\n               callback(i);\n            }\n        } else if (this.value.step < 0) {\n            for (let i = this.value.start; i >= this.value.end; i += this.value.step) {\n                callback(i);\n            }\n        } else {\n            conzole.warn(`[range error] => 0 is not a valid step`);\n        }\n    }\n\n    public toString(): string {\n        return `[${this.value.start}:${this.value.end}:${this.value.step}]`;\n    }\n}\n","import * as Expr from \"./types/expression\";\nimport * as Stmt from \"./types/statement\";\nimport { Console } from \"./console\";\nimport { Scope } from \"./scope\";\nimport { TokenType, Token } from \"./token\";\nimport { Runtime } from \"./runtime\";\nimport { $Any } from \"./types/any\";\nimport { $Boolean } from \"./types/boolean\";\nimport { $Class } from \"./types/class\";\nimport { $Dictionary } from \"./types/dictionary\";\nimport { $Function } from \"./types/function\";\nimport { $List } from \"./types/list\";\nimport { $Null } from \"./types/null\";\nimport { $Number } from \"./types/number\";\nimport { $Object } from \"./types/object\";\nimport { $Range, RangeValue } from \"./types/range\";\nimport { $String } from \"./types/string\";\nimport { $Void } from \"./types/void\";\nimport { DataType } from \"./types/type.enum\";\nimport { capitalize } from \"./utils\";\nimport { Scanner } from \"./scanner\";\nimport { Parser } from \"./parser\";\nimport { $Iterator } from \"./types/iterator\";\ndeclare var conzole: Console;\n\nexport class Interpreter\n    implements Expr.ExprVisitor<$Any>, Stmt.StmtVisitor<$Any>\n{\n    public global = new Scope();\n    public scope = this.global;\n    public errors: string[] = [];\n    private scanner = new Scanner();\n    private parser = new Parser();\n    public strings = {\n        next: new $String(\"next\"),\n    };\n\n    constructor() {\n        this.global.set(\"math\", new $Dictionary(Runtime.Math));\n        this.global.set(\"console\", new $Dictionary(Runtime.Console));\n        this.global.set(\"echo\", Runtime.Console.get(\"log\"));\n        this.global.set(\"re\", Runtime.Utils.get(\"re\"));\n        this.global.set(\"iter\", Runtime.Utils.get(\"iter\"));\n        this.global.set(\"delay\", Runtime.Utils.get(\"delay\"));\n        this.global.set(\"fetch\", Runtime.Utils.get(\"fetch\"));\n        this.parser.errorLevel = 0;\n    }\n\n    private evaluate(expr: Expr.Expr): $Any {\n        return (expr.result = expr.accept(this));\n    }\n\n    private execute(stmt: Stmt.Stmt): $Any {\n        return (stmt.result = stmt.accept(this));\n    }\n\n    public eval(stmt: Stmt.Stmt): any {\n        try {\n            return {\n                error: false,\n                value: stmt.accept(this).toString(),\n            };\n        } catch (e: any) {\n            return {\n                error: true,\n                value: e.message,\n            };\n        }\n    }\n\n    public interpet(statements: Stmt.Stmt[]): Stmt.Stmt[] {\n        this.errors = [];\n        for (const statement of statements) {\n            try {\n                this.execute(statement);\n            } catch (e: any) {\n                conzole.error(e.message);\n                this.errors.push(e.message);\n                if (this.errors.length > 100) {\n                    this.errors.push(\"Runtime Error limit exceeded\");\n                    return statements;\n                }\n            }\n        }\n        return statements;\n    }\n\n    public error(message: string): void {\n        throw new Error(`Runtime Error => ${message}`);\n    }\n\n    public visitExpressionStmt(stmt: Stmt.Expression): $Any {\n        return this.evaluate(stmt.expression);\n    }\n\n    public visitPrintStmt(stmt: Stmt.Print): $Any {\n        const data = this.evaluate(stmt.expression);\n        conzole.log(data.toString());\n        return data;\n    }\n\n    public visitVarStmt(stmt: Stmt.Var): $Any {\n        let value = new $Null();\n        if (stmt.initializer !== null) {\n            value = this.evaluate(stmt.initializer);\n        }\n        if (value.isLambda()) {\n            (value as any).name = stmt.name.lexeme;\n        }\n        this.scope.define(stmt.name.lexeme, value);\n        return value;\n    }\n\n    public visitVariableExpr(expr: Expr.Variable): $Any {\n        return this.scope.get(expr.name.lexeme, expr.name);\n    }\n\n    public visitPostfixExpr(expr: Expr.Postfix): $Any {\n        const value = this.scope.get(expr.name.lexeme, expr.name);\n        const newValue = new $Number(value.value + expr.increment);\n        this.scope.assign(expr.name.lexeme, newValue);\n        return value;\n    }\n\n    public visitListExpr(expr: Expr.List): $Any {\n        const values: $Any[] = [];\n        for (const expression of expr.value) {\n            if (expression instanceof Expr.Spread) {\n                const value = this.evaluate(expression.value);\n                this.spreadAnyIntoList(value, values);\n            } else if (expression instanceof Expr.Range) {\n                const range: RangeValue = (this.evaluate(expression) as $Range)\n                    .value;\n                range.step = range.step ? range.step : 1;\n                if (range.step > 0 && range.start <= range.end) {\n                    for (let i = range.start; i <= range.end; i += range.step) {\n                        values.push(new $Number(i));\n                    }\n                } else if (range.step < 0 && range.start >= range.end) {\n                    for (let i = range.start; i >= range.end; i += range.step) {\n                        values.push(new $Number(i));\n                    }\n                } else {\n                    this.error(\n                        `Invalid range expression at line ${expression.line} with range value of [${range.start}:${range.end}:${range.step}]`\n                    );\n                }\n            } else {\n                const value = this.evaluate(expression);\n                values.push(value);\n            }\n        }\n        return new $List(values);\n    }\n\n    private spreadAnyIntoList(value: $Any, values: $Any[]): void {\n        const it = new $Iterator(value);\n        while (!($Iterator.next(it, [], this) as $Iterator).iter.done.value) {\n            values.push(it.iter.value);\n        }\n    }\n\n    public visitZtringExpr(expr: Expr.Ztring): $Any {\n        return new $String(expr.value);\n    }\n\n    private templateParse(source: string): string {\n        const tokens = this.scanner.scan(source);\n        const statements = this.parser.parse(tokens);\n        if (this.parser.errors.length) {\n            this.error(`Template string  error: ${this.parser.errors[0]}`);\n        }\n        let result = \"\";\n        for (const statement of statements) {\n            result += this.execute(statement).toString();\n        }\n        return result;\n    }\n\n    public visitTemplateExpr(expr: Expr.Template): $Any {\n        const result = expr.value.replace(\n            /\\$\\{([\\s\\S]+?)\\}/g,\n            (m, placeholder) => {\n                if (placeholder[placeholder.length] !== \";\") {\n                    placeholder += \";\";\n                }\n                return this.templateParse(placeholder);\n            }\n        );\n        return new $String(result);\n    }\n\n    public visitRegExExpr(expr: Expr.RegEx): $Any {\n        /*\n        return new RegExEntity(expr.value);\n        */ return new $Null();\n    }\n\n    public visitAssignExpr(expr: Expr.Assign): $Any {\n        const value = this.evaluate(expr.value);\n        this.scope.assign(expr.name.lexeme, value);\n        return value;\n    }\n\n    public visitBinaryExpr(expr: Expr.Binary): $Any {\n        if (\n            expr.left instanceof Expr.Spread &&\n            expr.right instanceof Expr.Spread\n        ) {\n            return this.spreadBinaryExpr(\n                expr.left.value,\n                expr.right.value,\n                expr.operator\n            );\n        }\n\n        const left = this.evaluate(expr.left);\n        const right = this.evaluate(expr.right);\n\n        switch (expr.operator.type) {\n            case TokenType.Minus:\n            case TokenType.MinusEqual:\n                return new $Number(left.value - right.value);\n            case TokenType.Slash:\n            case TokenType.SlashEqual:\n                return new $Number(left.value / right.value);\n            case TokenType.Star:\n            case TokenType.StarEqual:\n                return new $Number(left.value * right.value);\n            case TokenType.Percent:\n            case TokenType.PercentEqual:\n                return new $Number(left.value % right.value);\n            case TokenType.Plus:\n            case TokenType.PlusEqual:\n                if (left.isNumber() && right.isNumber()) {\n                    return new $Number(left.value + right.value);\n                }\n                if (left.isString() && right.isString()) {\n                    return new $String(left.value + right.value);\n                }\n                if (left.isList() && right.isList()) {\n                    return new $List(left.value.concat(right.value));\n                }\n                if (left.isDictionary() && right.isDictionary()) {\n                    return new $Dictionary(\n                        new Map([...left.value, ...right.value])\n                    );\n                }\n                return new $String(left.toString() + right.toString());\n            case TokenType.Pipe:\n                return new $Number(left.value | right.value);\n            case TokenType.Caret:\n                return new $Number(left.value ^ right.value);\n            case TokenType.Greater:\n                return new $Boolean(left.value > right.value);\n            case TokenType.GreaterEqual:\n                return new $Boolean(left.value >= right.value);\n            case TokenType.Less:\n                return new $Boolean(left.value < right.value);\n            case TokenType.LessEqual:\n                return new $Boolean(left.value <= right.value);\n            case TokenType.EqualEqual:\n                return new $Boolean(left.value === right.value);\n            case TokenType.BangEqual:\n                return new $Boolean(left.value !== right.value);\n            case TokenType.LessEqualGreater:\n                if (left.value < right.value) {\n                    return new $Number(-1);\n                } else if (left.value > right.value) {\n                    return new $Number(1);\n                } else {\n                    return new $Number(0);\n                }\n            default:\n                this.error(\"Unknown binary operator \" + expr.operator);\n                return new $Null(); // unreachable\n        }\n    }\n    /*\n    private spreadBinaryComparission(left: Expr.Expr, right: Expr.Expr): $Any {\n        const lit = new $Iterator(this.evaluate(left));\n        const rit = new $Iterator(this.evaluate(right));\n        while (true) {\n            ($Iterator.next(lit, [], this) as $Iterator);\n            ($Iterator.next(rit, [], this) as $Iterator);\n            if (lit.iter.done.value || rit.iter.done.value) {\n                // one of the iterators completed\n                break;\n            }\n            if (lit.iter.value.value !== rit.iter.value.value) {\n               return new $Boolean(false);\n            }\n        }\n        if (lit.iter.done.value && rit.iter.done.value) {\n            return new $Boolean(true);\n        }\n        return new $Boolean(false);\n    } */\n\n    private spreadBinaryExpr(\n        left: Expr.Expr,\n        right: Expr.Expr,\n        operator: Token\n    ): $Any {\n        const lit = new $Iterator(this.evaluate(left));\n        const rit = new $Iterator(this.evaluate(right));\n        const result: $Any[] = [];\n        while (true) {\n            $Iterator.next(lit, [], this);\n            $Iterator.next(rit, [], this);\n            if (lit.iter.done.value || rit.iter.done.value) {\n                // one of the iterators completed\n                break;\n            }\n            const binary = new Expr.Binary(\n                new Expr.Literal(lit.iter.value, left.line),\n                operator,\n                new Expr.Literal(rit.iter.value, right.line),\n                operator.line\n            );\n            result.push(this.evaluate(binary));\n        }\n        return new $List(result);\n    }\n\n    public visitLogicalExpr(expr: Expr.Logical): $Any {\n        const left = this.evaluate(expr.left);\n\n        if (expr.operator.type === TokenType.Or) {\n            if (left.isTruthy()) {\n                return left;\n            }\n        } else {\n            if (!left.isTruthy()) {\n                return left;\n            }\n        }\n\n        return this.evaluate(expr.right);\n    }\n\n    public visitTernaryExpr(expr: Expr.Ternary): $Any {\n        return this.evaluate(expr.condition).isTruthy()\n            ? this.evaluate(expr.thenExpr)\n            : this.evaluate(expr.elseExpr);\n    }\n\n    public visitNullCoalescingExpr(expr: Expr.NullCoalescing): $Any {\n        const left = this.evaluate(expr.left);\n        if (left.isNull()) {\n            return this.evaluate(expr.right);\n        }\n        return left;\n    }\n\n    public visitGroupingExpr(expr: Expr.Grouping): $Any {\n        return this.evaluate(expr.expression);\n    }\n\n    public visitLiteralExpr(expr: Expr.Literal): $Any {\n        return expr.value;\n    }\n\n    public visitUnaryExpr(expr: Expr.Unary): $Any {\n        const right = this.evaluate(expr.right);\n        switch (expr.operator.type) {\n            case TokenType.Minus:\n                return new $Number(-Number(right.value));\n            case TokenType.Bang:\n                return new $Boolean(!right.isTruthy());\n            case TokenType.PlusPlus:\n            case TokenType.MinusMinus:\n                if (!right.isNumber()) {\n                    this.error(\n                        `Invalid right-hand side expression in prefix operation:  \"${\n                            DataType[right.type]\n                        } ${right} is not a number`\n                    );\n                }\n                const newValue =\n                    Number(right.value) +\n                    (expr.operator.type === TokenType.PlusPlus ? 1 : -1);\n                if (expr.right instanceof Expr.Variable) {\n                    this.scope.assign(\n                        expr.right.name.lexeme,\n                        new $Number(newValue)\n                    );\n                } else if (expr.right instanceof Expr.Get) {\n                    const assing = new Expr.Set(\n                        expr.right.entity,\n                        expr.right.key,\n                        new Expr.Literal(new $Number(newValue), expr.line),\n                        expr.line\n                    );\n                    this.evaluate(assing);\n                } else {\n                    this.error(\n                        `Invalid right-hand side expression in prefix operation:  ${expr.right}`\n                    );\n                }\n                return new $Number(newValue);\n            default:\n                this.error(`Unknown unary operator ' + expr.operator`);\n                return new $Null(); // should be unreachable\n        }\n    }\n\n    public executeBlock(statements: Stmt.Stmt[], nextScope: Scope): $Any {\n        const currentScope = this.scope;\n        this.scope = nextScope;\n        for (const statement of statements) {\n            statement.result = this.execute(statement);\n        }\n        this.scope = currentScope;\n        return new $Void(\"block\");\n    }\n\n    public visitBlockStmt(stmt: Stmt.Block): $Any {\n        return this.executeBlock(stmt.statements, new Scope(this.scope));\n    }\n\n    public visitIfStmt(stmt: Stmt.If): $Any {\n        if (this.evaluate(stmt.condition).isTruthy()) {\n            return this.execute(stmt.thenStmt);\n        } else if (stmt.elseStmt !== null) {\n            return this.execute(stmt.elseStmt);\n        }\n    }\n\n    public visitWhileStmt(stmt: Stmt.While): $Any {\n        const currentScope = this.scope;\n        while (this.evaluate(stmt.condition).isTruthy()) {\n            try {\n                this.execute(stmt.loop);\n            } catch (e: any) {\n                this.scope = currentScope;\n                if (e instanceof $Any && e.type === DataType.Break) {\n                    break;\n                } else if (e instanceof $Any && e.type === DataType.Continue) {\n                    continue;\n                } else {\n                    throw e;\n                }\n            }\n        }\n        return new $Void(\"while\");\n    }\n\n    public visitDoWhileStmt(stmt: Stmt.DoWhile): $Any {\n        const currentScope = this.scope;\n        do {\n            try {\n                this.execute(stmt.loop);\n            } catch (e: any) {\n                this.scope = currentScope;\n                if (e instanceof $Any && e.type === DataType.Break) {\n                    break;\n                } else if (e instanceof $Any && e.type === DataType.Continue) {\n                    continue;\n                } else {\n                    throw e;\n                }\n            }\n        } while (this.evaluate(stmt.condition).isTruthy());\n        return new $Void(\"dowhile\");\n    }\n\n    public visitForeachStmt(stmt: Stmt.Foreach): $Any {\n        const it = new $Iterator(this.evaluate(stmt.iterable));\n        const restoreScope = this.scope;\n        let hasItems = false;\n        while (!($Iterator.next(it, [], this) as $Iterator).iter.done.value) {\n            hasItems = true;\n            const foreachScope = new Scope(this.scope);\n            foreachScope.set(stmt.name.lexeme, it.iter.value);\n            if (stmt.key) {\n                foreachScope.set(stmt.key.lexeme, it.iter.index);\n            }\n            try {\n                this.executeBlock([stmt.loop], foreachScope);\n            } catch (e: any) {\n                this.scope = restoreScope;\n                if (e instanceof $Any && e.type === DataType.Break) {\n                    break;\n                } else if (e instanceof $Any && e.type === DataType.Continue) {\n                    continue;\n                } else {\n                    throw e;\n                }\n            }\n        }\n        if (!hasItems && stmt.none) {\n            this.execute(stmt.none);\n        }\n        return new $Void(\"foreach\");\n    }\n\n    public visitCallExpr(expr: Expr.Call): $Any {\n        // verify callee is a function\n        const callee = this.evaluate(expr.callee);\n        if (!callee.isFunction()) {\n            this.error(`${callee} is not a function`);\n        }\n\n        // set this in function scope\n        let thiz: any = null;\n        if (expr.callee instanceof Expr.Get) {\n            if (expr.callee.entity instanceof Expr.Base) {\n                thiz = this.scope.get(\"this\", expr.paren);\n            } else {\n                thiz = this.evaluate(expr.callee.entity);\n            }\n        } else if (expr.thiz !== null) {\n            thiz = expr.thiz;\n        }\n\n        // evaluate function arguments\n        const args = [];\n        for (const argument of expr.args) {\n            if (argument instanceof Expr.Spread) {\n                const value = this.evaluate(argument.value);\n                this.spreadAnyIntoList(value, args);\n            } else {\n                args.push(this.evaluate(argument));\n            }\n        }\n\n        // pass arguments to function\n        const func = callee as $Function;\n        if (args.length !== func.arity && func.arity !== -1) {\n            conzole.warn(\n                `Warning at (${expr.paren.line}): ${callee} mismatched argument count; \\n Expected ${func.arity} but got ${args.length} `\n            );\n            if (args.length < func.arity) {\n                for (let i = args.length; i <= func.arity; ++i) {\n                    args.push(new $Null());\n                }\n            }\n        }\n        // execute function\n        return func.call(thiz, args, this);\n    }\n\n    public visitBaseExpr(expr: Expr.Base): $Any {\n        const thiz = this.scope.get(expr.paren.lexeme, expr.paren);\n\n        if (!thiz.isObject()) {\n            this.error(\"base expression can be used only inside methods\");\n        }\n\n        const clazz: $Class = (thiz as $Object).conztructor as $Class;\n        const parent = clazz.parent;\n        if (parent.isNull()) {\n            this.error(\n                \"Class \" + clazz + \" has not been extended and has no base\"\n            );\n        }\n\n        return parent;\n    }\n\n    public visitNewExpr(expr: Expr.New): $Any {\n        const newCall = expr.clazz as Expr.Call;\n        // internal class definition instance\n        const clazz: $Class = this.evaluate(newCall.callee) as $Class;\n\n        if (!clazz.isClass()) {\n            this.error(\n                `'${clazz}' is not a class. 'new' statement must be used with classes.`\n            );\n        }\n        // new object\n        const entity = new $Object(new Map(), clazz);\n        // constructor method of the class\n        const conztructor = clazz.get(new $String(\"constructor\")) as $Function;\n        if (conztructor.isFunction()) {\n            /*\n            const args: $Any[] = [];\n            for (const arg of newCall.args) {\n                args.push(this.evaluate(arg));\n            }\n            conztructor.call(this, entity, args);\n            */\n            this.evaluate(\n                new Expr.Call(\n                    new Expr.Get(\n                        new Expr.Literal(entity, expr.line),\n                        new Expr.Key(conztructor.declaration.name, expr.line),\n                        TokenType.Dot,\n                        expr.line\n                    ),\n                    conztructor.declaration.name,\n                    newCall.args,\n                    entity,\n                    expr.line\n                )\n            );\n        }\n        return entity;\n    }\n\n    public visitDictionaryExpr(expr: Expr.Dictionary): $Any {\n        const dict = new $Dictionary(new Map());\n        for (const property of expr.properties) {\n            if (property instanceof Expr.Spread) {\n                const value = this.evaluate(property.value);\n                const it = new $Iterator(value);\n                while (\n                    !($Iterator.next(it, [], this) as $Iterator).iter.done.value\n                ) {\n                    dict.set(it.iter.index, it.iter.value);\n                }\n            } else {\n                const key = this.evaluate((property as Expr.Set).key);\n                const value = this.evaluate((property as Expr.Set).value);\n                dict.set(key, value);\n            }\n        }\n        return dict;\n    }\n\n    public visitKeyExpr(expr: Expr.Key): $Any {\n        return new $Any(expr.name.literal);\n    }\n\n    public visitGetExpr(expr: Expr.Get): $Any {\n        const entity = this.evaluate(expr.entity);\n        const key = this.evaluate(expr.key);\n        if (entity.isNull() && expr.type === TokenType.QuestionDot) {\n            return new $Null();\n        }\n        return entity.get(key);\n    }\n\n    public visitSetExpr(expr: Expr.Set): $Any {\n        const entity = this.evaluate(expr.entity);\n        const key = this.evaluate(expr.key);\n        const value = this.evaluate(expr.value);\n        entity.set(key, value);\n        return value.value;\n    }\n\n    public visitFuncStmt(stmt: Stmt.Func): $Any {\n        const func = new $Function(stmt, this.scope);\n        this.scope.define(stmt.name.lexeme, func);\n        return func;\n    }\n\n    public visitClassStmt(stmt: Stmt.Class): $Any {\n        let parent: $Any;\n\n        if (stmt.parent === null) {\n            parent = new $Null();\n        } else {\n            parent = this.scope.get(stmt.parent.lexeme, stmt.parent);\n        }\n\n        const methods = new Map<any, $Any>();\n\n        for (const method of stmt.methods) {\n            methods.set(method.name.lexeme, new $Function(method, this.scope));\n        }\n        const clazz = new $Class(stmt.name.lexeme, methods, parent);\n        this.scope.define(stmt.name.lexeme, clazz);\n        return clazz;\n    }\n\n    public visitLambdaExpr(expr: Expr.Lambda): $Any {\n        const lambda: Stmt.Func = expr.lambda as Stmt.Func;\n        const func: $Function = new $Function(lambda, this.scope);\n        return func;\n    }\n\n    public visitReturnStmt(stmt: Stmt.Return): $Any {\n        let value = new $Null();\n        if (stmt.value) {\n            value = this.evaluate(stmt.value);\n        }\n        throw new $Any(value, DataType.Return);\n    }\n\n    public visitBreakStmt(stmt: Stmt.Break): $Any {\n        throw new $Any(null, DataType.Break);\n    }\n\n    public visitContinueStmt(stmt: Stmt.Continue): $Any {\n        throw new $Any(null, DataType.Continue);\n    }\n\n    public visitRangeExpr(expr: Expr.Range): $Any {\n        const start = expr.start ? this.evaluate(expr.start).value : null;\n        const end = expr.end ? this.evaluate(expr.end).value : null;\n        const step = expr.step\n            ? this.evaluate(expr.step).value\n            : start <= end\n            ? 1\n            : -1;\n        return new $Range(new RangeValue(start, end, step));\n    }\n\n    public visitTypeofExpr(expr: Expr.Typeof): $Any {\n        const value = this.evaluate(expr.value);\n        return new $String(DataType[value.type].toLowerCase());\n    }\n\n    public visitIsExpr(expr: Expr.InstanceOf): $Any {\n        const left = this.evaluate(expr.left);\n        const right = DataType[capitalize(expr.right.lexeme) as never];\n        // is direct instance of class\n        if (left.isObject() && (left as $Object).name === expr.right.lexeme) {\n            return new $Boolean(true);\n        }\n        // is not a type\n        if (typeof right === \"undefined\" || isNaN(right as never)) {\n            return new $Boolean(false);\n        }\n        // is a type\n        return new $Boolean((left.type as unknown) === (right as unknown));\n    }\n\n    public visitInstanceOfExpr(expr: Expr.InstanceOf): $Any {\n        const left = this.evaluate(expr.left);\n        if (!left.isObject()) {\n            return new $Boolean(false);\n        }\n        const className = expr.right.lexeme;\n\n        // All instances derive from Object\n        if (className.toLowerCase() === \"object\") {\n            return new $Boolean(true);\n        }\n        const instance = left as $Object;\n        let conztructor = instance.conztructor as $Class;\n        if (conztructor.name === className) {\n            return new $Boolean(true);\n        }\n        while (!conztructor.parent.isNull()) {\n            conztructor = conztructor.parent as $Class;\n            if (conztructor.name === className) {\n                return new $Boolean(true);\n            }\n        }\n        return new $Boolean(false);\n    }\n\n    public visitVoidExpr(expr: Expr.Void): $Any {\n        this.evaluate(expr.value);\n        return new $Null();\n    }\n\n    public visitInExpr(expr: Expr.In): $Any {\n        const key = this.evaluate(expr.key);\n        const entity = this.evaluate(expr.entity);\n        if (entity.isKeyValue()) {\n            return new $Boolean(entity.value.has(key.value));\n        }\n        if (entity.isList()) {\n            return new $Boolean(typeof entity.value[key.value] !== \"undefined\");\n        }\n        if (entity.isString()) {\n            return new $Boolean(entity.value.includes(key.value));\n        }\n        this.error(\n            `Operator \"in\" can't be used on type ${\n                DataType[entity.type]\n            } with value \"${entity}\"`\n        );\n        return new $Null();\n    }\n\n    public visitCharExpr(expr: Expr.Char): $Any {\n        const value = this.evaluate(expr.value);\n        return new $String(String.fromCharCode(value.value));\n    }\n\n    public visitSpreadExpr(expr: Expr.Spread): $Any {\n        // this.error(`unexpected spread '...' operator at line ${expr.line}`);\n        return new $Null();\n    }\n\n    public visitDeleteExpr(expr: Expr.Delete): $Any {\n        if (!(expr.value instanceof Expr.Get)) {\n            const value = this.evaluate(expr.value);\n            const type = DataType[value.type].toLowerCase();\n            this.error(\n                `Can't delete on type ${type} with value '${value}'. Not a Dictionary, Class or Entity`\n            );\n            return new $Null();\n        }\n\n        const getExpr = expr.value as Expr.Get;\n        const entity = this.evaluate(getExpr.entity);\n        const key = this.evaluate(getExpr.key);\n        return entity.delete(key);\n    }\n}\n","export enum ConsoleMessageType {\n    User,\n    Error,\n    Warning,\n    Info\n}\n\nexport class ConsoleMessage {\n    public time: Date;\n    public text: any;\n    public type: ConsoleMessageType;\n}\n\nexport class Console {\n\n    public messages: ConsoleMessage[];\n\n    constructor() {\n        this.messages = [];\n    }\n\n    private add(message: any, type: ConsoleMessageType): void {\n        this.messages.push({\n            text: message,\n            time: new Date(),\n            // tslint:disable-next-line\n            type: type\n        });\n    }\n\n    public clear(): void {\n        this.messages = [];\n    }\n\n    public log(message: any) {\n        this.add(message, ConsoleMessageType.User);\n    }\n\n    public warn(message: any) {\n        this.add(message, ConsoleMessageType.Warning);\n    }\n\n    public error(message: any) {\n        this.add(message, ConsoleMessageType.Error);\n        // throw new Error(\"\");\n    }\n\n    public info(message: any) {\n        this.add(message, ConsoleMessageType.Info);\n    }\n\n    public first(): any {\n        return this.messages[0].text;\n    }\n\n    public last(): any {\n        return this.messages[this.messages.length - 1].text;\n    }\n\n    public print(): any {\n        return console.log(this.messages.map((cm) => cm.text));\n    }\n\n}\n","export const DemoSourceCode = `\n// slicing strings\nprint \"one two three four\"[4:7:1]; // prints two\nprint \"hello world\"[::-1]; //prints dlrow olleh\n\n// range operator on list construction\nprint [0:10:3]; // prints a list [0,3,6,9]\nprint [1..5]; // prints [1,2,3,4,5]\n\n// spread operator\nprint {...[1,2,3]}; // prints {0: 1; 1: 2; 2: 3}\nprint ...1..3 == ...1..3; // prints [true,true,true];\nprint ...\"abz\" <=> ...\"ayc\"; // prints [0,-1,1]\n\n\n// functions\nfunction BasicFunction(text) {\n    print text;\n}\nBasicFunction('BasicFunctionArgument');\n\n// classes\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n    hello() {\n        print this.name + ' says hi';\n    }\n}\nclass Student extends Person {\n    constructor(name, grade) {\n        base.constructor(name);\n        this.grade = grade;\n    }\n    hello() {\n        base.hello();\n        print 'from ' + this.grade + ' grade';\n    }\n}\nvar student = new Student('John', 3);\nstudent.hello();\n\n// Recursive function\nfunction factorialize(n) {\n    if (n < 0) {\n        return -1;\n    }\n    if (n == 0) {\n        return 1;\n    }\n    return (n * factorialize(n - 1));\n}\nprint 'factor of 11: ' + factorialize(11);\n// same as factorialize but with ternary\n// and short form function definition\n@factor(n) =>\n    n < 0 ? -1 : (n == 0 ? 1 : (n * factorialize(n - 1)));\nprint 'factor of 11: ' +factor(11);\n\n// nested function returns function\n@add(a) => @(b) => @(c) => a + b + c;\nprint add(100)(20)(3);\n\n// literals\nvar literal = {\n    firstname: \"John\",\n    lastname: \"Doe\",\n    records: {\n        prev: \"previous\",\n        next: \"next\"\n    }\n};\nprint literal.records.prev;\n\n// safe navigator operator ?.\nprint literal.safeNavigator?.propertyDoesNotExist;\n\n// delete operator\ndelete literal.firstname;\n\n// new scope test\n{\n    var a = {a: 'one'};\n    var b = {b: 'two'};\n    var c = a + b;\n    print c; // prints {a: 'one', b: 'two'}\n}\n// new scope test\n{\n    var a = {d: 'three'};\n    var b = {e: 'four'};\n    var c = a + b;\n    print c; // prints {d: 'three', e: 'four'}\n}\n\n// typeof, is, instanceof operator\nprint typeof Person;\nprint typeof student;\nprint 'Student is Class: ' + (Student is Class);\nprint 'student is Object: ' + (student is Object);\nprint 'student is Person: ' + (student is Person);\nprint 'student is Student: ' + (student is Student);\nprint 'student instanceof Person: ' + (student instanceof Person);\nprint typeof '' + 'string';\n\n// iterators\nvar it = iter(['one', 'two', 'three']);\nwhile (!it.next().done) {\n    print it.value;\n}\n\n// foreach statement\nforeach (item with key in ['one', 'two', 'three']) {\n    print item;\n}\n\n// foreach statement with none\nforeach (item  in []) {\n    print item;\n} none {\n    print \"no items\";\n}\n\n// spread operator\n{\n    var a1 = ['one', 'two', 'three'];\n    var b2 = [...a1, ...\"spreading\"];\n    var d3 = {\n        ...a1,\n        ...\"spreding\"\n    };\n    print b2;\n    print d3;\n}\n\n// loggin into js console\necho ('execution finished');\n\n// fetching data. Currently unparsed text\nfetch ('https://jsonplaceholder.typicode.com/todos/1', @(res) {\n    echo(res);\n});\n`;\n","import { Scanner } from './scanner';\nimport { Parser } from './parser';\nimport { Interpreter } from './interpreter';\nimport { Console } from './console';\nimport { DemoSourceCode } from './demos/demo';\nimport { Stmt } from './types/statement';\ndeclare var window: any;\ndeclare var global: any;\n\nconst conzole = new Console();\n\nconst atscript = {\n    execute: (source: string): Stmt[] => {\n        const scanner = new Scanner();\n        const parser = new Parser();\n        const interpreter = new Interpreter();\n        const tokens = scanner.scan(source);\n        if (scanner.errors.length) {\n            scanner.errors.forEach((e) => {\n                conzole.error(e);\n            });\n            return [];\n        }\n        const statements = parser.parse(tokens);\n        if (parser.errors.length) {\n            parser.errors.forEach((e) => {\n                conzole.error(e);\n            });\n            return [];\n        }\n        return interpreter.interpet(statements);\n    },\n    interpreter: Interpreter,\n    parser: Parser,\n    scanner: Scanner\n};\n\nif (typeof window !== 'undefined') {\n    window.demoSourceCode = DemoSourceCode;\n    window.atscript = atscript;\n    window.conzole = conzole;\n} else {\n    global.conzole = conzole;\n    exports.atscript = atscript;\n}\n"],"names":["TokenType","DataType","__webpack_require__","g","globalThis","this","Function","e","window","Token","constructor","type","lexeme","literal","line","col","name","toString","isDigit","char","isAlpha","capitalize","word","charAt","toUpperCase","substr","toLowerCase","Scanner","scan","source","tokens","errors","current","start","eof","getToken","push","message","length","Eof","advance","peek","addToken","tokenType","text","substring","match","expected","peekNext","comment","multilineComment","error","string","quote","value","String","Template","number","Number","identifier","capitalized","And","Identifier","LeftParen","RightParen","LeftBracket","RightBracket","LeftBrace","RightBrace","Comma","Semicolon","Caret","Dollar","Hash","Arrow","Colon","StarEqual","Star","PercentEqual","Percent","Or","Pipe","Ampersand","GreaterEqual","Greater","BangEqual","Bang","QuestionQuestion","QuestionDot","Question","EqualEqual","Equal","PlusPlus","PlusEqual","Plus","MinusMinus","Return","MinusEqual","Minus","LessEqualGreater","LessEqual","Less","DotDotDot","DotDot","Dot","SlashEqual","Slash","Error","Expr","Assign","super","accept","visitor","visitAssignExpr","Base","paren","visitBaseExpr","Binary","left","operator","right","visitBinaryExpr","Call","callee","args","thiz","visitCallExpr","Char","visitCharExpr","Delete","visitDeleteExpr","Dictionary","properties","visitDictionaryExpr","Get","entity","key","visitGetExpr","Grouping","expression","visitGroupingExpr","In","visitInExpr","InstanceOf","visitInstanceOfExpr","Is","visitIsExpr","Key","visitKeyExpr","Lambda","lambda","visitLambdaExpr","Logical","visitLogicalExpr","List","visitListExpr","Literal","visitLiteralExpr","New","clazz","visitNewExpr","NullCoalescing","visitNullCoalescingExpr","Postfix","increment","visitPostfixExpr","Range","end","step","visitRangeExpr","RegEx","visitRegExExpr","Set","visitSetExpr","Spread","visitSpreadExpr","visitTemplateExpr","Ternary","condition","thenExpr","elseExpr","visitTernaryExpr","Typeof","visitTypeofExpr","Unary","visitUnaryExpr","Variable","visitVariableExpr","Void","visitVoidExpr","Ztring","visitZtringExpr","Stmt","Block","statements","visitBlockStmt","Break","keyword","visitBreakStmt","Class","parent","methods","visitClassStmt","Continue","visitContinueStmt","DoWhile","loop","visitDoWhileStmt","Expression","visitExpressionStmt","Foreach","iterable","none","visitForeachStmt","Func","params","body","visitFuncStmt","If","thenStmt","elseStmt","visitIfStmt","Print","visitPrintStmt","visitReturnStmt","Var","initializer","visitVarStmt","While","visitWhileStmt","$Any","Any","isString","isNull","Null","isBoolean","Boolean","isNumber","isRange","isFunction","isClass","isLambda","isList","isDictionary","isObject","Object","isTruthy","size","isEqual","other","isKeyValue","get","conzole","set","delete","$Boolean","$Null","$Number","$Error","Parser","errorLevel","parse","declaration","synchronize","types","check","previous","consume","extraSemicolon","token","warning","warn","For","Do","classDeclaration","funcDeclaration","varDeclaration","statement","Extends","kind","funcParamsBody","funcParams","block","arrow","ifStatement","printStatement","doWhileStatement","whileStatement","forStatement","foreachStatement","returnStatement","breakStatement","continueStatement","expressionStatement","Else","With","None","assignment","expr","ternary","nullCoalescing","logicalOr","rightExpr","logicalAnd","equality","instanceof","in","Instanceof","comparison","addition","modulus","multiplication","typeof","range","unary","newKeyword","construct","call","primary","consumed","dotGet","bracketGet","False","True","Regex","dictionary","list","leftBrace","values","leftBracket","Scope","Map","define","has","assign","$Callable","arity","interpreter","$Function","closure","scope","i","restoreScope","executeBlock","$List","runtime","result","iterate","join","static","sort","a","b","fromJavaScriptMethod","each","map","$String","interpeter","replace","splits","split","str","$Void","$RegExp","RegExp","$Dictionary","forEach","index","indexOf","IteratorValue","done","inner","$Iterator","iter","complete","it","listNext","dictionaryNext","stringNext","numberNext","rangeNext","strings","next","newIndex","newValue","dict","keys","jsName","argValues","arg","fromJavaScriptFuncNumber","func","fromJavaScriptFuncVoid","first","Runtime","Console","console","log","info","Math","ceil","cos","floor","max","min","PI","pow","random","round","sin","sqrt","tan","trunc","Utils","setTimeout","fetch","then","response","json","$Class","$Object","conztructor","method","RangeValue","normalize","$Range","callback","Interpreter","global","scanner","parser","evaluate","execute","stmt","eval","interpet","data","spreadAnyIntoList","templateParse","m","placeholder","spreadBinaryExpr","concat","lit","rit","binary","assing","nextScope","currentScope","hasItems","foreachScope","argument","newCall","property","isNaN","className","includes","fromCharCode","getExpr","ConsoleMessageType","messages","add","time","Date","clear","User","Warning","Info","last","print","cm","atscript","demoSourceCode","exports"],"sourceRoot":""}